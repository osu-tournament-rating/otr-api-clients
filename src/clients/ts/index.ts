//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { CreateAxiosDefaults } from "axios";import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export abstract class OtrApiWrapperBase {
  protected configuration: IOtrApiWrapperConfiguration;

  constructor(configuration: IOtrApiWrapperConfiguration) {
    this.configuration = configuration;
  }

  protected getBaseUrl(..._: any[]): string { return this.configuration.baseUrl }
}

/**
* Request parameters available for use when requesting {@link BeatmapsWrapper.prototype.get | api/v1/beatmaps/[key]}
*/
export type BeatmapsGetRequestParams = {
    /**
    * (required) Search key
    */
    key: number;
}

export class BeatmapsWrapper extends OtrApiWrapperBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: IOtrApiWrapperConfiguration) {

        super(configuration);

        this.instance = axios.create(this.configuration.clientConfiguration);
        this.baseUrl = this.getBaseUrl("");

        if (this.configuration.postConfigureClientMethod) {
            this.configuration.postConfigureClientMethod(this.instance);
        }
    }

    /**
    * List all beatmaps
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @return Returns all beatmaps
    */
    public list( cancelToken?: CancelToken): Promise<OtrApiResponse<BeatmapDTO[]>> {

        let url_ = this.baseUrl + "/api/v1/beatmaps";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processList(_response);
        });
    }

    protected processList(response: AxiosResponse): Promise<OtrApiResponse<BeatmapDTO[]>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BeatmapDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OtrApiResponse<BeatmapDTO[]>>(new OtrApiResponse<BeatmapDTO[]>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<BeatmapDTO[]>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Get a beatmap by versatile search
    *
    * Get a beatmap searching first by id, then by osu! beatmap id
    * 
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link BeatmapsGetRequestParams})
    * @return Returns a beatmap
    */
    public get(params: BeatmapsGetRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<BeatmapDTO>> {
        const {
            key
        } = params;

        let url_ = this.baseUrl + "/api/v1/beatmaps/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<OtrApiResponse<BeatmapDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a beatmap for the search key does not exist", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BeatmapDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<BeatmapDTO>>(new OtrApiResponse<BeatmapDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<BeatmapDTO>>(new OtrApiResponse(status, _headers, null as any));
    }
}

/**
* Request parameters available for use when requesting {@link ClientsWrapper.prototype.patchRateLimit | api/v1/clients/[id]/ratelimit}
*/
export type ClientsPatchRateLimitRequestParams = {
    /**
    * (required) The client id
    */
    id: number;
    /**
    * (optional) The new rate limit for the client
    */
    rateLimitOverride?: number | undefined;
}

export class ClientsWrapper extends OtrApiWrapperBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: IOtrApiWrapperConfiguration) {

        super(configuration);

        this.instance = axios.create(this.configuration.clientConfiguration);
        this.baseUrl = this.getBaseUrl("");

        if (this.configuration.postConfigureClientMethod) {
            this.configuration.postConfigureClientMethod(this.instance);
        }
    }

    /**
    * Set the rate limit for a client
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link ClientsPatchRateLimitRequestParams})
    * @return Returns the patched client
    */
    public patchRateLimit(params: ClientsPatchRateLimitRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<OAuthClientDTO>> {
        const {
            id, 
            rateLimitOverride
        } = params;

        let url_ = this.baseUrl + "/api/v1/clients/{id}/ratelimit?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (rateLimitOverride === null)
            throw new Error("The parameter 'rateLimitOverride' cannot be null.");
        else if (rateLimitOverride !== undefined)
            url_ += "rateLimitOverride=" + encodeURIComponent("" + rateLimitOverride) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPatchRateLimit(_response);
        });
    }

    protected processPatchRateLimit(response: AxiosResponse): Promise<OtrApiResponse<OAuthClientDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If the provided id does not belong to a client", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OAuthClientDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<OAuthClientDTO>>(new OtrApiResponse<OAuthClientDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<OAuthClientDTO>>(new OtrApiResponse(status, _headers, null as any));
    }
}

/**
* Request parameters available for use when requesting {@link FilteringWrapper.prototype.filter | api/v1/filtering}
*/
export type FilteringFilterRequestParams = {
    /**
    * (optional) The filtering request
    */
    body?: FilteringRequestDTO | undefined;
}

export class FilteringWrapper extends OtrApiWrapperBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: IOtrApiWrapperConfiguration) {

        super(configuration);

        this.instance = axios.create(this.configuration.clientConfiguration);
        this.baseUrl = this.getBaseUrl("");

        if (this.configuration.postConfigureClientMethod) {
            this.configuration.postConfigureClientMethod(this.instance);
        }
    }

    /**
    * Filter a list of users based on the criteria as described in
    * API.DTOs.FilteringResultDTO
    *
    * Requires Authorization:
    * 
    * Claim(s): user, client
    * @param params Request parameters (see {@link FilteringFilterRequestParams})
    * @return The filtering result
    */
    public filter(params: FilteringFilterRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<FilteringResultDTO>> {
        const {
            body
        } = params;

        let url_ = this.baseUrl + "/api/v1/filtering";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFilter(_response);
        });
    }

    protected processFilter(response: AxiosResponse): Promise<OtrApiResponse<FilteringResultDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Errors encountered during validation", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FilteringResultDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<FilteringResultDTO>>(new OtrApiResponse<FilteringResultDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<FilteringResultDTO>>(new OtrApiResponse(status, _headers, null as any));
    }
}

/**
* Request parameters available for use when requesting {@link GamesWrapper.prototype.createAdminNote | api/v1/games/[id]/notes}
*/
export type GamesCreateAdminNoteRequestParams = {
    /**
    * (required) Game id
    */
    id: number;
    /**
    * (optional) 
    */
    body?: string | undefined;
}

/**
* Request parameters available for use when requesting {@link GamesWrapper.prototype.listAdminNotes | api/v1/games/[id]/notes}
*/
export type GamesListAdminNotesRequestParams = {
    /**
    * (required) Game id
    */
    id: number;
}

/**
* Request parameters available for use when requesting {@link GamesWrapper.prototype.updateAdminNote | api/v1/games/[id]/notes/[noteId]}
*/
export type GamesUpdateAdminNoteRequestParams = {
    /**
    * (required) Game id
    */
    id: number;
    /**
    * (required) Admin note id
    */
    noteId: number;
    /**
    * (optional) 
    */
    body?: string | undefined;
}

/**
* Request parameters available for use when requesting {@link GamesWrapper.prototype.deleteAdminNote | api/v1/games/[id]/notes/[noteId]}
*/
export type GamesDeleteAdminNoteRequestParams = {
    /**
    * (required) Game id
    */
    id: number;
    /**
    * (required) Admin note id
    */
    noteId: number;
}

/**
* Request parameters available for use when requesting {@link GamesWrapper.prototype.update | api/v1/games/[id]}
*/
export type GamesUpdateRequestParams = {
    /**
    * (required) The game id
    */
    id: number;
    /**
    * (optional) JsonPatch data
    */
    body?: Operation[] | undefined;
}

/**
* Request parameters available for use when requesting {@link GamesWrapper.prototype.delete | api/v1/games/[id]}
*/
export type GamesDeleteRequestParams = {
    /**
    * (required) Game id
    */
    id: number;
}

export class GamesWrapper extends OtrApiWrapperBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: IOtrApiWrapperConfiguration) {

        super(configuration);

        this.instance = axios.create(this.configuration.clientConfiguration);
        this.baseUrl = this.getBaseUrl("");

        if (this.configuration.postConfigureClientMethod) {
            this.configuration.postConfigureClientMethod(this.instance);
        }
    }

    /**
    * Creates an admin note for a game
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link GamesCreateAdminNoteRequestParams})
    * @return Returns the created admin note
    */
    public createAdminNote(params: GamesCreateAdminNoteRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO>> {
        const {
            id, 
            body
        } = params;

        let url_ = this.baseUrl + "/api/v1/games/{id}/notes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateAdminNote(_response);
        });
    }

    protected processCreateAdminNote(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a game matching the given id does not exist", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the authorized user does not exist", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdminNoteDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse<AdminNoteDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * List all admin notes from a game
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link GamesListAdminNotesRequestParams})
    * @return Returns all admin notes from a game
    */
    public listAdminNotes(params: GamesListAdminNotesRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO[]>> {
        const {
            id
        } = params;

        let url_ = this.baseUrl + "/api/v1/games/{id}/notes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListAdminNotes(_response);
        });
    }

    protected processListAdminNotes(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO[]>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a game matching the given id does not exist", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdminNoteDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OtrApiResponse<AdminNoteDTO[]>>(new OtrApiResponse<AdminNoteDTO[]>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO[]>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Updates an admin note for a game
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link GamesUpdateAdminNoteRequestParams})
    * @return Returns the updated admin note
    */
    public updateAdminNote(params: GamesUpdateAdminNoteRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO>> {
        const {
            id, 
            noteId, 
            body
        } = params;

        let url_ = this.baseUrl + "/api/v1/games/{id}/notes/{noteId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (noteId === undefined || noteId === null)
            throw new Error("The parameter 'noteId' must be defined.");
        url_ = url_.replace("{noteId}", encodeURIComponent("" + noteId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAdminNote(_response);
        });
    }

    protected processUpdateAdminNote(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a game matching the given id does not exist.\r\nIf an admin note matching the given noteId does not exist", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the requester did not create the admin note", status, _responseText, _headers, result403);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdminNoteDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse<AdminNoteDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Deletes an admin note for a game
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link GamesDeleteAdminNoteRequestParams})
    * @return Returns the updated admin note
    */
    public deleteAdminNote(params: GamesDeleteAdminNoteRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO>> {
        const {
            id, 
            noteId
        } = params;

        let url_ = this.baseUrl + "/api/v1/games/{id}/notes/{noteId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (noteId === undefined || noteId === null)
            throw new Error("The parameter 'noteId' must be defined.");
        url_ = url_.replace("{noteId}", encodeURIComponent("" + noteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAdminNote(_response);
        });
    }

    protected processDeleteAdminNote(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a game matching the given id does not exist.\r\nIf an admin note matching the given noteId does not exist", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdminNoteDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse<AdminNoteDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Amend game data
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link GamesUpdateRequestParams})
    * @return Returns the patched game
    */
    public update(params: GamesUpdateRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<GameDTO>> {
        const {
            id, 
            body
        } = params;

        let url_ = this.baseUrl + "/api/v1/games/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<OtrApiResponse<GameDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If the provided id does not belong to a game", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("If JsonPatch data is malformed", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GameDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<GameDTO>>(new OtrApiResponse<GameDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<GameDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Delete a game
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link GamesDeleteRequestParams})
    * @return The game was deleted successfully
    */
    public delete(params: GamesDeleteRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<void>> {
        const {
            id
        } = params;

        let url_ = this.baseUrl + "/api/v1/games/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<OtrApiResponse<void>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse<void>(status, _headers, null as any));

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("The game does not exist", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse(status, _headers, null as any));
    }
}

/**
* Request parameters available for use when requesting {@link GameScoresWrapper.prototype.createAdminNote | api/v1/gamescores/[id]/notes}
*/
export type GameScoresCreateAdminNoteRequestParams = {
    /**
    * (required) Score id
    */
    id: number;
    /**
    * (optional) 
    */
    body?: string | undefined;
}

/**
* Request parameters available for use when requesting {@link GameScoresWrapper.prototype.listAdminNotes | api/v1/gamescores/[id]/notes}
*/
export type GameScoresListAdminNotesRequestParams = {
    /**
    * (required) Score id
    */
    id: number;
}

/**
* Request parameters available for use when requesting {@link GameScoresWrapper.prototype.updateAdminNote | api/v1/gamescores/[id]/notes/[noteId]}
*/
export type GameScoresUpdateAdminNoteRequestParams = {
    /**
    * (required) Score id
    */
    id: number;
    /**
    * (required) Admin note id
    */
    noteId: number;
    /**
    * (optional) 
    */
    body?: string | undefined;
}

/**
* Request parameters available for use when requesting {@link GameScoresWrapper.prototype.deleteAdminNote | api/v1/gamescores/[id]/notes/[noteId]}
*/
export type GameScoresDeleteAdminNoteRequestParams = {
    /**
    * (required) Score id
    */
    id: number;
    /**
    * (required) Admin note id
    */
    noteId: number;
}

/**
* Request parameters available for use when requesting {@link GameScoresWrapper.prototype.update | api/v1/gamescores/[id]}
*/
export type GameScoresUpdateRequestParams = {
    /**
    * (required) The score id
    */
    id: number;
    /**
    * (optional) JsonPatch data
    */
    body?: Operation[] | undefined;
}

/**
* Request parameters available for use when requesting {@link GameScoresWrapper.prototype.delete | api/v1/gamescores/[id]}
*/
export type GameScoresDeleteRequestParams = {
    /**
    * (required) Score id
    */
    id: number;
}

export class GameScoresWrapper extends OtrApiWrapperBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: IOtrApiWrapperConfiguration) {

        super(configuration);

        this.instance = axios.create(this.configuration.clientConfiguration);
        this.baseUrl = this.getBaseUrl("");

        if (this.configuration.postConfigureClientMethod) {
            this.configuration.postConfigureClientMethod(this.instance);
        }
    }

    /**
    * Creates an admin note for a score
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link GameScoresCreateAdminNoteRequestParams})
    * @return Returns the created admin note
    */
    public createAdminNote(params: GameScoresCreateAdminNoteRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO>> {
        const {
            id, 
            body
        } = params;

        let url_ = this.baseUrl + "/api/v1/gamescores/{id}/notes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateAdminNote(_response);
        });
    }

    protected processCreateAdminNote(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a score matching the given id does not exist", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the authorized user does not exist", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdminNoteDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse<AdminNoteDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * List all admin notes for a score
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link GameScoresListAdminNotesRequestParams})
    * @return Returns all admin notes from a score
    */
    public listAdminNotes(params: GameScoresListAdminNotesRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO[]>> {
        const {
            id
        } = params;

        let url_ = this.baseUrl + "/api/v1/gamescores/{id}/notes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListAdminNotes(_response);
        });
    }

    protected processListAdminNotes(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO[]>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a score matching the given id does not exist", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdminNoteDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OtrApiResponse<AdminNoteDTO[]>>(new OtrApiResponse<AdminNoteDTO[]>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO[]>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Updates an admin note for a score
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link GameScoresUpdateAdminNoteRequestParams})
    * @return Returns the updated admin note
    */
    public updateAdminNote(params: GameScoresUpdateAdminNoteRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO>> {
        const {
            id, 
            noteId, 
            body
        } = params;

        let url_ = this.baseUrl + "/api/v1/gamescores/{id}/notes/{noteId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (noteId === undefined || noteId === null)
            throw new Error("The parameter 'noteId' must be defined.");
        url_ = url_.replace("{noteId}", encodeURIComponent("" + noteId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAdminNote(_response);
        });
    }

    protected processUpdateAdminNote(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a score matching the given id does not exist.\r\nIf an admin note matching the given noteId does not exist", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the requester did not create the admin note", status, _responseText, _headers, result403);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdminNoteDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse<AdminNoteDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Deletes an admin note for a score
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link GameScoresDeleteAdminNoteRequestParams})
    * @return Returns the updated admin note
    */
    public deleteAdminNote(params: GameScoresDeleteAdminNoteRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO>> {
        const {
            id, 
            noteId
        } = params;

        let url_ = this.baseUrl + "/api/v1/gamescores/{id}/notes/{noteId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (noteId === undefined || noteId === null)
            throw new Error("The parameter 'noteId' must be defined.");
        url_ = url_.replace("{noteId}", encodeURIComponent("" + noteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAdminNote(_response);
        });
    }

    protected processDeleteAdminNote(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a score matching the given id does not exist.\r\nIf an admin note matching the given noteId does not exist", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdminNoteDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse<AdminNoteDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Amend score data
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link GameScoresUpdateRequestParams})
    * @return Returns the patched score
    */
    public update(params: GameScoresUpdateRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<GameScoreDTO>> {
        const {
            id, 
            body
        } = params;

        let url_ = this.baseUrl + "/api/v1/gamescores/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<OtrApiResponse<GameScoreDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If the provided id does not belong to a score", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("If JsonPatch data is malformed", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GameScoreDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<GameScoreDTO>>(new OtrApiResponse<GameScoreDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<GameScoreDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Delete a score
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link GameScoresDeleteRequestParams})
    * @return The score was deleted successfully
    */
    public delete(params: GameScoresDeleteRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<void>> {
        const {
            id
        } = params;

        let url_ = this.baseUrl + "/api/v1/gamescores/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<OtrApiResponse<void>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse<void>(status, _headers, null as any));

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("The score does not exist", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse(status, _headers, null as any));
    }
}

/**
* Request parameters available for use when requesting {@link LeaderboardsWrapper.prototype.get | api/v1/leaderboards}
*/
export type LeaderboardsGetRequestParams = {
    /**
    * (optional) 
    */
    ruleset?: Ruleset | undefined;
    /**
    * (optional) The zero-indexed page offset. Page 0 returns the first PageSize results.
    */
    page?: number | undefined;
    /**
    * (optional) The number of elements to return per page
    */
    pageSize?: number | undefined;
    /**
    * (optional) Defines whether the leaderboard should be global or filtered by country
    */
    chartType?: LeaderboardChartType | undefined;
    /**
    * (optional) 
    */
    filter?: LeaderboardFilterDTO | undefined;
}

export class LeaderboardsWrapper extends OtrApiWrapperBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: IOtrApiWrapperConfiguration) {

        super(configuration);

        this.instance = axios.create(this.configuration.clientConfiguration);
        this.baseUrl = this.getBaseUrl("");

        if (this.configuration.postConfigureClientMethod) {
            this.configuration.postConfigureClientMethod(this.instance);
        }
    }

    /**
    * Undocumented
    *
    * Requires Authorization:
    * 
    * Claim(s): user
    * @param params Request parameters (see {@link LeaderboardsGetRequestParams})
    * @return Success
    */
    public get(params: LeaderboardsGetRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<LeaderboardDTO>> {
        const {
            ruleset, 
            page, 
            pageSize, 
            chartType, 
            filter
        } = params;

        let url_ = this.baseUrl + "/api/v1/leaderboards?";
        if (ruleset === null)
            throw new Error("The parameter 'ruleset' cannot be null.");
        else if (ruleset !== undefined)
            url_ += "Ruleset=" + encodeURIComponent("" + ruleset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (chartType === null)
            throw new Error("The parameter 'chartType' cannot be null.");
        else if (chartType !== undefined)
            url_ += "ChartType=" + encodeURIComponent("" + chartType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<OtrApiResponse<LeaderboardDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LeaderboardDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<LeaderboardDTO>>(new OtrApiResponse<LeaderboardDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<LeaderboardDTO>>(new OtrApiResponse(status, _headers, null as any));
    }
}

/**
* Request parameters available for use when requesting {@link MatchesWrapper.prototype.createAdminNote | api/v1/matches/[id]/notes}
*/
export type MatchesCreateAdminNoteRequestParams = {
    /**
    * (required) Match id
    */
    id: number;
    /**
    * (optional) 
    */
    body?: string | undefined;
}

/**
* Request parameters available for use when requesting {@link MatchesWrapper.prototype.listAdminNotes | api/v1/matches/[id]/notes}
*/
export type MatchesListAdminNotesRequestParams = {
    /**
    * (required) Match id
    */
    id: number;
}

/**
* Request parameters available for use when requesting {@link MatchesWrapper.prototype.updateAdminNote | api/v1/matches/[id]/notes/[noteId]}
*/
export type MatchesUpdateAdminNoteRequestParams = {
    /**
    * (required) Match id
    */
    id: number;
    /**
    * (required) Admin note id
    */
    noteId: number;
    /**
    * (optional) 
    */
    body?: string | undefined;
}

/**
* Request parameters available for use when requesting {@link MatchesWrapper.prototype.deleteAdminNote | api/v1/matches/[id]/notes/[noteId]}
*/
export type MatchesDeleteAdminNoteRequestParams = {
    /**
    * (required) Match id
    */
    id: number;
    /**
    * (required) Admin note id
    */
    noteId: number;
}

/**
* Request parameters available for use when requesting {@link MatchesWrapper.prototype.list | api/v1/matches}
*/
export type MatchesListRequestParams = {
    /**
    * (optional) Filters results for Database.Entities.Matches with a
	* matching Database.Enums.Ruleset
    */
    ruleset?: Ruleset | undefined;
    /**
    * (optional) Filters results for Database.Entities.Matches with a partially
	* matching Database.Entities.Match.Name
    */
    name?: string | undefined;
    /**
    * (optional) Filters results for Database.Entities.Matches with a
	* Database.Entities.Match.StartTime greater than this value
    */
    dateMin?: Date | undefined;
    /**
    * (optional) Filters results for Database.Entities.Matches with an
	* Database.Entities.Match.EndTime less than this value
    */
    dateMax?: Date | undefined;
    /**
    * (optional) Filters results for Database.Entities.Matches with a
	* matching Database.Enums.Verification.VerificationStatus
    */
    verificationStatus?: VerificationStatus | undefined;
    /**
    * (optional) Filters results for Database.Entities.Matches with a matching Database.Enums.Verification.MatchRejectionReason
    */
    rejectionReason?: MatchRejectionReason | undefined;
    /**
    * (optional) Filters results for Database.Entities.Matches with a matching Database.Enums.Verification.MatchProcessingStatus
    */
    processingStatus?: MatchProcessingStatus | undefined;
    /**
    * (optional) Filters results for Database.Entities.Matches where the id of the
	* Database.Entities.User that submitted it matches this value
    */
    submittedBy?: number | undefined;
    /**
    * (optional) Filters results for Database.Entities.Matches where the id of the
	* Database.Entities.User that verified it matches this value
    */
    verifiedBy?: number | undefined;
    /**
    * (optional) Controls the manner in which results are sorted
    */
    sort?: MatchQuerySortType | undefined;
    /**
    * (optional) Denotes whether to sort results in ascending or descending order
    */
    sortDescending?: boolean | undefined;
    /**
    * (optional) Controls the number of matches to return. Functions as a "page size".
	* Default: 100 Constraints: Minimum 1, Maximum 5000
    */
    limit?: number | undefined;
    /**
    * (optional) Controls which block of size limit to return.
	* Default: 1, Constraints: Minimum 1
    */
    page?: number | undefined;
}

/**
* Request parameters available for use when requesting {@link MatchesWrapper.prototype.get | api/v1/matches/[id]}
*/
export type MatchesGetRequestParams = {
    /**
    * (required) Match id
    */
    id: number;
}

/**
* Request parameters available for use when requesting {@link MatchesWrapper.prototype.update | api/v1/matches/[id]}
*/
export type MatchesUpdateRequestParams = {
    /**
    * (required) The match id
    */
    id: number;
    /**
    * (optional) JsonPatch data
    */
    body?: Operation[] | undefined;
}

/**
* Request parameters available for use when requesting {@link MatchesWrapper.prototype.delete | api/v1/matches/[id]}
*/
export type MatchesDeleteRequestParams = {
    /**
    * (required) Match id
    */
    id: number;
}

/**
* Request parameters available for use when requesting {@link MatchesWrapper.prototype.getMatches | api/v1/matches/player/[osuId]}
*/
export type MatchesGetMatchesRequestParams = {
    osuId: number;
    /**
    * (optional) 
    */
    ruleset?: Ruleset | undefined;
}

export class MatchesWrapper extends OtrApiWrapperBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: IOtrApiWrapperConfiguration) {

        super(configuration);

        this.instance = axios.create(this.configuration.clientConfiguration);
        this.baseUrl = this.getBaseUrl("");

        if (this.configuration.postConfigureClientMethod) {
            this.configuration.postConfigureClientMethod(this.instance);
        }
    }

    /**
    * Creates an admin note for a match
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link MatchesCreateAdminNoteRequestParams})
    * @return Returns the created admin note
    */
    public createAdminNote(params: MatchesCreateAdminNoteRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO>> {
        const {
            id, 
            body
        } = params;

        let url_ = this.baseUrl + "/api/v1/matches/{id}/notes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateAdminNote(_response);
        });
    }

    protected processCreateAdminNote(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a match matching the given id does not exist", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the authorized user does not exist", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdminNoteDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse<AdminNoteDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * List all admin notes from a match
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link MatchesListAdminNotesRequestParams})
    * @return Returns all admin notes from a match
    */
    public listAdminNotes(params: MatchesListAdminNotesRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO[]>> {
        const {
            id
        } = params;

        let url_ = this.baseUrl + "/api/v1/matches/{id}/notes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListAdminNotes(_response);
        });
    }

    protected processListAdminNotes(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO[]>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a match matching the given id does not exist", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdminNoteDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OtrApiResponse<AdminNoteDTO[]>>(new OtrApiResponse<AdminNoteDTO[]>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO[]>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Updates an admin note for a match
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link MatchesUpdateAdminNoteRequestParams})
    * @return Returns the updated admin note
    */
    public updateAdminNote(params: MatchesUpdateAdminNoteRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO>> {
        const {
            id, 
            noteId, 
            body
        } = params;

        let url_ = this.baseUrl + "/api/v1/matches/{id}/notes/{noteId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (noteId === undefined || noteId === null)
            throw new Error("The parameter 'noteId' must be defined.");
        url_ = url_.replace("{noteId}", encodeURIComponent("" + noteId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAdminNote(_response);
        });
    }

    protected processUpdateAdminNote(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a match matching the given id does not exist.\r\nIf an admin note matching the given noteId does not exist", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the requester did not create the admin note", status, _responseText, _headers, result403);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdminNoteDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse<AdminNoteDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Deletes an admin note for a match
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link MatchesDeleteAdminNoteRequestParams})
    * @return Returns the updated admin note
    */
    public deleteAdminNote(params: MatchesDeleteAdminNoteRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO>> {
        const {
            id, 
            noteId
        } = params;

        let url_ = this.baseUrl + "/api/v1/matches/{id}/notes/{noteId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (noteId === undefined || noteId === null)
            throw new Error("The parameter 'noteId' must be defined.");
        url_ = url_.replace("{noteId}", encodeURIComponent("" + noteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAdminNote(_response);
        });
    }

    protected processDeleteAdminNote(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a match matching the given id does not exist.\r\nIf an admin note matching the given noteId does not exist", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdminNoteDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse<AdminNoteDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Gets all matches
    *
    * Results are ordered by id and support pagination. All match data is included.
    * 
    * Requires Authorization:
    * 
    * Claim(s): user, client
    * @param params Request parameters (see {@link MatchesListRequestParams})
    * @return Returns the desired page of matches
    */
    public list(params: MatchesListRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<MatchDTOPagedResultDTO>> {
        const {
            ruleset, 
            name, 
            dateMin, 
            dateMax, 
            verificationStatus, 
            rejectionReason, 
            processingStatus, 
            submittedBy, 
            verifiedBy, 
            sort, 
            sortDescending, 
            limit, 
            page
        } = params;

        let url_ = this.baseUrl + "/api/v1/matches?";
        if (ruleset === null)
            throw new Error("The parameter 'ruleset' cannot be null.");
        else if (ruleset !== undefined)
            url_ += "Ruleset=" + encodeURIComponent("" + ruleset) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (dateMin === null)
            throw new Error("The parameter 'dateMin' cannot be null.");
        else if (dateMin !== undefined)
            url_ += "DateMin=" + encodeURIComponent(dateMin ? "" + dateMin.toISOString() : "") + "&";
        if (dateMax === null)
            throw new Error("The parameter 'dateMax' cannot be null.");
        else if (dateMax !== undefined)
            url_ += "DateMax=" + encodeURIComponent(dateMax ? "" + dateMax.toISOString() : "") + "&";
        if (verificationStatus === null)
            throw new Error("The parameter 'verificationStatus' cannot be null.");
        else if (verificationStatus !== undefined)
            url_ += "VerificationStatus=" + encodeURIComponent("" + verificationStatus) + "&";
        if (rejectionReason === null)
            throw new Error("The parameter 'rejectionReason' cannot be null.");
        else if (rejectionReason !== undefined)
            url_ += "RejectionReason=" + encodeURIComponent("" + rejectionReason) + "&";
        if (processingStatus === null)
            throw new Error("The parameter 'processingStatus' cannot be null.");
        else if (processingStatus !== undefined)
            url_ += "ProcessingStatus=" + encodeURIComponent("" + processingStatus) + "&";
        if (submittedBy === null)
            throw new Error("The parameter 'submittedBy' cannot be null.");
        else if (submittedBy !== undefined)
            url_ += "SubmittedBy=" + encodeURIComponent("" + submittedBy) + "&";
        if (verifiedBy === null)
            throw new Error("The parameter 'verifiedBy' cannot be null.");
        else if (verifiedBy !== undefined)
            url_ += "VerifiedBy=" + encodeURIComponent("" + verifiedBy) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processList(_response);
        });
    }

    protected processList(response: AxiosResponse): Promise<OtrApiResponse<MatchDTOPagedResultDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MatchDTOPagedResultDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<MatchDTOPagedResultDTO>>(new OtrApiResponse<MatchDTOPagedResultDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<MatchDTOPagedResultDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Get a match
    *
    * Requires Authorization:
    * 
    * Claim(s): user, client
    * @param params Request parameters (see {@link MatchesGetRequestParams})
    * @return Returns a match
    */
    public get(params: MatchesGetRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<MatchDTO>> {
        const {
            id
        } = params;

        let url_ = this.baseUrl + "/api/v1/matches/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<OtrApiResponse<MatchDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a match does not exist for the given id", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MatchDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<MatchDTO>>(new OtrApiResponse<MatchDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<MatchDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Amend match data
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link MatchesUpdateRequestParams})
    * @return Returns the patched match
    */
    public update(params: MatchesUpdateRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<MatchDTO>> {
        const {
            id, 
            body
        } = params;

        let url_ = this.baseUrl + "/api/v1/matches/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<OtrApiResponse<MatchDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If the provided id does not belong to a match", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("If JsonPatch data is malformed", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MatchDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<MatchDTO>>(new OtrApiResponse<MatchDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<MatchDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Delete a match
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link MatchesDeleteRequestParams})
    * @return The match was deleted successfully
    */
    public delete(params: MatchesDeleteRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<void>> {
        const {
            id
        } = params;

        let url_ = this.baseUrl + "/api/v1/matches/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<OtrApiResponse<void>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse<void>(status, _headers, null as any));

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("The match does not exist", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Undocumented
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link MatchesGetMatchesRequestParams})
    * @return Success
    */
    public getMatches(params: MatchesGetMatchesRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<void>> {
        const {
            osuId, 
            ruleset
        } = params;

        let url_ = this.baseUrl + "/api/v1/matches/player/{osuId}?";
        if (osuId === undefined || osuId === null)
            throw new Error("The parameter 'osuId' must be defined.");
        url_ = url_.replace("{osuId}", encodeURIComponent("" + osuId));
        if (ruleset === null)
            throw new Error("The parameter 'ruleset' cannot be null.");
        else if (ruleset !== undefined)
            url_ += "ruleset=" + encodeURIComponent("" + ruleset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMatches(_response);
        });
    }

    protected processGetMatches(response: AxiosResponse): Promise<OtrApiResponse<void>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse<void>(status, _headers, null as any));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse(status, _headers, null as any));
    }
}

/**
* Request parameters available for use when requesting {@link MeWrapper.prototype.getStats | api/v1/me/stats}
*/
export type MeGetStatsRequestParams = {
    /**
    * (optional) Ruleset to filter for
    */
    ruleset?: Ruleset | undefined;
    /**
    * (optional) Filter from earliest date
    */
    dateMin?: Date | undefined;
    /**
    * (optional) Filter to latest date
    */
    dateMax?: Date | undefined;
}

/**
* Request parameters available for use when requesting {@link MeWrapper.prototype.updateRuleset | api/v1/me/settings/ruleset}
*/
export type MeUpdateRulesetRequestParams = {
    /**
    * (optional) 
    */
    body?: Ruleset | undefined;
}

export class MeWrapper extends OtrApiWrapperBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: IOtrApiWrapperConfiguration) {

        super(configuration);

        this.instance = axios.create(this.configuration.clientConfiguration);
        this.baseUrl = this.getBaseUrl("");

        if (this.configuration.postConfigureClientMethod) {
            this.configuration.postConfigureClientMethod(this.instance);
        }
    }

    /**
    * Get the currently logged in user
    *
    * Requires Authorization:
    * 
    * Claim(s): user
    * @return Returns the currently logged in user
    */
    public get( cancelToken?: CancelToken): Promise<OtrApiResponse<UserDTO>> {

        let url_ = this.baseUrl + "/api/v1/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<OtrApiResponse<UserDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 302) {
            const _responseText = response.data;
            return throwException("Redirects to `GET` `/users/{id}`", status, _responseText, _headers);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<UserDTO>>(new OtrApiResponse<UserDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<UserDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Get player stats for the currently logged in user
    *
    * If no ruleset is provided, the player's default is used. Database.Enums.Ruleset.Osu is used as a fallback.
    * If a ruleset is provided but the player has no data for it, all optional fields of the response will be null.
    * API.DTOs.PlayerStatsDTO.PlayerInfo will always be populated as long as a player is found.
    * If no date range is provided, gets all stats without considering date
    * 
    * Requires Authorization:
    * 
    * Claim(s): user
    * @param params Request parameters (see {@link MeGetStatsRequestParams})
    * @return Returns the currently logged in user's player stats
    */
    public getStats(params: MeGetStatsRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<PlayerStatsDTO>> {
        const {
            ruleset, 
            dateMin, 
            dateMax
        } = params;

        let url_ = this.baseUrl + "/api/v1/me/stats?";
        if (ruleset === null)
            throw new Error("The parameter 'ruleset' cannot be null.");
        else if (ruleset !== undefined)
            url_ += "ruleset=" + encodeURIComponent("" + ruleset) + "&";
        if (dateMin === null)
            throw new Error("The parameter 'dateMin' cannot be null.");
        else if (dateMin !== undefined)
            url_ += "dateMin=" + encodeURIComponent(dateMin ? "" + dateMin.toISOString() : "") + "&";
        if (dateMax === null)
            throw new Error("The parameter 'dateMax' cannot be null.");
        else if (dateMax !== undefined)
            url_ += "dateMax=" + encodeURIComponent(dateMax ? "" + dateMax.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStats(_response);
        });
    }

    protected processGetStats(response: AxiosResponse): Promise<OtrApiResponse<PlayerStatsDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 302) {
            const _responseText = response.data;
            return throwException("Redirects to `GET` `/stats/{key}`", status, _responseText, _headers);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlayerStatsDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<PlayerStatsDTO>>(new OtrApiResponse<PlayerStatsDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<PlayerStatsDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Update the ruleset for the currently logged in user
    *
    * Requires Authorization:
    * 
    * Claim(s): user
    * @param params Request parameters (see {@link MeUpdateRulesetRequestParams})
    * @return If the operation was successful
    */
    public updateRuleset(params: MeUpdateRulesetRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<void>> {
        const {
            body
        } = params;

        let url_ = this.baseUrl + "/api/v1/me/settings/ruleset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRuleset(_response);
        });
    }

    protected processUpdateRuleset(response: AxiosResponse): Promise<OtrApiResponse<void>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 308) {
            const _responseText = response.data;
            return throwException("Redirects to `POST` `/users/{id}/settings/ruleset`", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the operation was not successful", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse<void>(status, _headers, null as any));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Sync the ruleset of the currently logged in user to their osu! ruleset
    *
    * Requires Authorization:
    * 
    * Claim(s): user
    * @return If the operation was successful
    */
    public syncRuleset( cancelToken?: CancelToken): Promise<OtrApiResponse<void>> {

        let url_ = this.baseUrl + "/api/v1/me/settings/ruleset:sync";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSyncRuleset(_response);
        });
    }

    protected processSyncRuleset(response: AxiosResponse): Promise<OtrApiResponse<void>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 308) {
            const _responseText = response.data;
            return throwException("Redirect", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the operation was not successful", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse<void>(status, _headers, null as any));

        } else if (status === 307) {
            const _responseText = response.data;
            return throwException("Redirects to `POST` `/users/{id}/settings/ruleset:sync`", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse(status, _headers, null as any));
    }
}

/**
* Request parameters available for use when requesting {@link OAuthWrapper.prototype.authorize | api/v1/oauth/authorize}
*/
export type OAuthAuthorizeRequestParams = {
    /**
    * (optional) The osu! authorization code
    */
    code?: string | undefined;
}

/**
* Request parameters available for use when requesting {@link OAuthWrapper.prototype.authorizeClient | api/v1/oauth/token}
*/
export type OAuthAuthorizeClientRequestParams = {
    /**
    * (optional) The id of the client
    */
    clientId?: number | undefined;
    /**
    * (optional) The secret of the client
    */
    clientSecret?: string | undefined;
}

/**
* Request parameters available for use when requesting {@link OAuthWrapper.prototype.refresh | api/v1/oauth/refresh}
*/
export type OAuthRefreshRequestParams = {
    /**
    * (optional) 
    */
    refreshToken?: string | undefined;
}

export class OAuthWrapper extends OtrApiWrapperBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: IOtrApiWrapperConfiguration) {

        super(configuration);

        this.instance = axios.create(this.configuration.clientConfiguration);
        this.baseUrl = this.getBaseUrl("");

        if (this.configuration.postConfigureClientMethod) {
            this.configuration.postConfigureClientMethod(this.instance);
        }
    }

    /**
    * Authorize using an osu! authorization code
    * @param params Request parameters (see {@link OAuthAuthorizeRequestParams})
    * @return Returns user access credentials
    */
    public authorize(params: OAuthAuthorizeRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AccessCredentialsDTO>> {
        const {
            code
        } = params;

        let url_ = this.baseUrl + "/api/v1/oauth/authorize?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = false

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthorize(_response);
        });
    }

    protected processAuthorize(response: AxiosResponse): Promise<OtrApiResponse<AccessCredentialsDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("If there was an error during authorization", status, _responseText, _headers, result401);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccessCredentialsDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<AccessCredentialsDTO>>(new OtrApiResponse<AccessCredentialsDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AccessCredentialsDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Authorize using client credentials
    * @param params Request parameters (see {@link OAuthAuthorizeClientRequestParams})
    * @return Returns client access credentials
    */
    public authorizeClient(params: OAuthAuthorizeClientRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AccessCredentialsDTO>> {
        const {
            clientId, 
            clientSecret
        } = params;

        let url_ = this.baseUrl + "/api/v1/oauth/token?";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        if (clientSecret === null)
            throw new Error("The parameter 'clientSecret' cannot be null.");
        else if (clientSecret !== undefined)
            url_ += "clientSecret=" + encodeURIComponent("" + clientSecret) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = false

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthorizeClient(_response);
        });
    }

    protected processAuthorizeClient(response: AxiosResponse): Promise<OtrApiResponse<AccessCredentialsDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If there was an error during authorization", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccessCredentialsDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<AccessCredentialsDTO>>(new OtrApiResponse<AccessCredentialsDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AccessCredentialsDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Create a new OAuth client
    *
    * Client secret is only returned from creation.
    * The user will have to reset the secret if they lose access.
    * 
    * Requires Authorization:
    * 
    * Claim(s): user
    * @return Returns created client credentials
    */
    public createClient( cancelToken?: CancelToken): Promise<OtrApiResponse<OAuthClientCreatedDTO>> {

        let url_ = this.baseUrl + "/api/v1/oauth/client";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateClient(_response);
        });
    }

    protected processCreateClient(response: AxiosResponse): Promise<OtrApiResponse<OAuthClientCreatedDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OAuthClientCreatedDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<OAuthClientCreatedDTO>>(new OtrApiResponse<OAuthClientCreatedDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<OAuthClientCreatedDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Generate new access credentials from a valid refresh token
    *
    * Generated access credentials will contain only a new access token,
    * and the given refresh token is returned with it
    * @param params Request parameters (see {@link OAuthRefreshRequestParams})
    * @return Returns access credentials containing a new access token
    */
    public refresh(params: OAuthRefreshRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AccessCredentialsDTO>> {
        const {
            refreshToken
        } = params;

        let url_ = this.baseUrl + "/api/v1/oauth/refresh?";
        if (refreshToken === null)
            throw new Error("The parameter 'refreshToken' cannot be null.");
        else if (refreshToken !== undefined)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = false

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: AxiosResponse): Promise<OtrApiResponse<AccessCredentialsDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the given refresh token is invalid, or there was an error during authorization", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccessCredentialsDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<AccessCredentialsDTO>>(new OtrApiResponse<AccessCredentialsDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AccessCredentialsDTO>>(new OtrApiResponse(status, _headers, null as any));
    }
}

/**
* Request parameters available for use when requesting {@link PlayersWrapper.prototype.createAdminNote | api/v1/players/[id]/notes}
*/
export type PlayersCreateAdminNoteRequestParams = {
    /**
    * (required) Player id
    */
    id: number;
    /**
    * (optional) 
    */
    body?: string | undefined;
}

/**
* Request parameters available for use when requesting {@link PlayersWrapper.prototype.listAdminNotes | api/v1/players/[id]/notes}
*/
export type PlayersListAdminNotesRequestParams = {
    /**
    * (required) Player id
    */
    id: number;
}

/**
* Request parameters available for use when requesting {@link PlayersWrapper.prototype.updateAdminNote | api/v1/players/[id]/notes/[noteId]}
*/
export type PlayersUpdateAdminNoteRequestParams = {
    /**
    * (required) Player id
    */
    id: number;
    /**
    * (required) Admin note id
    */
    noteId: number;
    /**
    * (optional) 
    */
    body?: string | undefined;
}

/**
* Request parameters available for use when requesting {@link PlayersWrapper.prototype.deleteAdminNote | api/v1/players/[id]/notes/[noteId]}
*/
export type PlayersDeleteAdminNoteRequestParams = {
    /**
    * (required) Player id
    */
    id: number;
    /**
    * (required) Admin note id
    */
    noteId: number;
}

/**
* Request parameters available for use when requesting {@link PlayersWrapper.prototype.get | api/v1/players/[key]}
*/
export type PlayersGetRequestParams = {
    key: string;
}

export class PlayersWrapper extends OtrApiWrapperBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: IOtrApiWrapperConfiguration) {

        super(configuration);

        this.instance = axios.create(this.configuration.clientConfiguration);
        this.baseUrl = this.getBaseUrl("");

        if (this.configuration.postConfigureClientMethod) {
            this.configuration.postConfigureClientMethod(this.instance);
        }
    }

    /**
    * Creates an admin note for a player
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link PlayersCreateAdminNoteRequestParams})
    * @return Returns the created admin note
    */
    public createAdminNote(params: PlayersCreateAdminNoteRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO>> {
        const {
            id, 
            body
        } = params;

        let url_ = this.baseUrl + "/api/v1/players/{id}/notes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateAdminNote(_response);
        });
    }

    protected processCreateAdminNote(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a player matching the given id does not exist", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the authorized user does not exist", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdminNoteDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse<AdminNoteDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * List all admin notes for a player
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link PlayersListAdminNotesRequestParams})
    * @return Returns all admin notes from a player
    */
    public listAdminNotes(params: PlayersListAdminNotesRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO[]>> {
        const {
            id
        } = params;

        let url_ = this.baseUrl + "/api/v1/players/{id}/notes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListAdminNotes(_response);
        });
    }

    protected processListAdminNotes(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO[]>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a player matching the given id does not exist", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdminNoteDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OtrApiResponse<AdminNoteDTO[]>>(new OtrApiResponse<AdminNoteDTO[]>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO[]>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Updates an admin note for a player
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link PlayersUpdateAdminNoteRequestParams})
    * @return Returns the updated admin note
    */
    public updateAdminNote(params: PlayersUpdateAdminNoteRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO>> {
        const {
            id, 
            noteId, 
            body
        } = params;

        let url_ = this.baseUrl + "/api/v1/players/{id}/notes/{noteId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (noteId === undefined || noteId === null)
            throw new Error("The parameter 'noteId' must be defined.");
        url_ = url_.replace("{noteId}", encodeURIComponent("" + noteId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAdminNote(_response);
        });
    }

    protected processUpdateAdminNote(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a player matching the given id does not exist.\r\nIf an admin note matching the given noteId does not exist", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the requester did not create the admin note", status, _responseText, _headers, result403);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdminNoteDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse<AdminNoteDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Deletes an admin note for a player
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link PlayersDeleteAdminNoteRequestParams})
    * @return Returns the updated admin note
    */
    public deleteAdminNote(params: PlayersDeleteAdminNoteRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO>> {
        const {
            id, 
            noteId
        } = params;

        let url_ = this.baseUrl + "/api/v1/players/{id}/notes/{noteId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (noteId === undefined || noteId === null)
            throw new Error("The parameter 'noteId' must be defined.");
        url_ = url_.replace("{noteId}", encodeURIComponent("" + noteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAdminNote(_response);
        });
    }

    protected processDeleteAdminNote(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a player matching the given id does not exist.\r\nIf an admin note matching the given noteId does not exist", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdminNoteDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse<AdminNoteDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Undocumented
    *
    * Requires Authorization:
    * 
    * Claim(s): user, client
    * @param params Request parameters (see {@link PlayersGetRequestParams})
    * @return Success
    */
    public get(params: PlayersGetRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<PlayerCompactDTO>> {
        const {
            key
        } = params;

        let url_ = this.baseUrl + "/api/v1/players/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<OtrApiResponse<PlayerCompactDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlayerCompactDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<PlayerCompactDTO>>(new OtrApiResponse<PlayerCompactDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<PlayerCompactDTO>>(new OtrApiResponse(status, _headers, null as any));
    }
}

/**
* Request parameters available for use when requesting {@link SearchWrapper.prototype.search | api/v1/search}
*/
export type SearchSearchRequestParams = {
    /**
    * (optional) The string to match against names of tournaments, matches, and usernames
    */
    searchKey?: string | undefined;
}

export class SearchWrapper extends OtrApiWrapperBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: IOtrApiWrapperConfiguration) {

        super(configuration);

        this.instance = axios.create(this.configuration.clientConfiguration);
        this.baseUrl = this.getBaseUrl("");

        if (this.configuration.postConfigureClientMethod) {
            this.configuration.postConfigureClientMethod(this.instance);
        }
    }

    /**
    * Search for tournaments, matches, and users
    *
    * Allows for partial or full searching on the names of tournaments, matches, and usernames
    * 
    * Requires Authorization:
    * 
    * Claim(s): user
    * @param params Request parameters (see {@link SearchSearchRequestParams})
    * @return Returns a list of all possible tournaments, matches, and usernames for the given search key
    */
    public search(params: SearchSearchRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<SearchResponseCollectionDTO>> {
        const {
            searchKey
        } = params;

        let url_ = this.baseUrl + "/api/v1/search?";
        if (searchKey === null)
            throw new Error("The parameter 'searchKey' cannot be null.");
        else if (searchKey !== undefined)
            url_ += "searchKey=" + encodeURIComponent("" + searchKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<OtrApiResponse<SearchResponseCollectionDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SearchResponseCollectionDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<SearchResponseCollectionDTO>>(new OtrApiResponse<SearchResponseCollectionDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<SearchResponseCollectionDTO>>(new OtrApiResponse(status, _headers, null as any));
    }
}

/**
* Request parameters available for use when requesting {@link StatsWrapper.prototype.get | api/v1/stats/[key]}
*/
export type StatsGetRequestParams = {
    /**
    * (required) Key used in versatile search
    */
    key: string;
    /**
    * (optional) Ruleset to filter for
    */
    ruleset?: Ruleset | undefined;
    /**
    * (optional) Filter from earliest date
    */
    dateMin?: Date | undefined;
    /**
    * (optional) Filter to latest date
    */
    dateMax?: Date | undefined;
}

/**
* Request parameters available for use when requesting {@link StatsWrapper.prototype.getRatingHistogram | api/v1/stats/histogram}
*/
export type StatsGetRatingHistogramRequestParams = {
    /**
    * (optional) 
    */
    ruleset?: Ruleset | undefined;
}

export class StatsWrapper extends OtrApiWrapperBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: IOtrApiWrapperConfiguration) {

        super(configuration);

        this.instance = axios.create(this.configuration.clientConfiguration);
        this.baseUrl = this.getBaseUrl("");

        if (this.configuration.postConfigureClientMethod) {
            this.configuration.postConfigureClientMethod(this.instance);
        }
    }

    /**
    * Get a player's stats
    *
    * Gets player by versatile search.
    * If no ruleset is provided, the player's default is used. Database.Enums.Ruleset.Osu is used as a fallback.
    * If a ruleset is provided but the player has no data for it, all optional fields of the response will be null.
    * API.DTOs.PlayerStatsDTO.PlayerInfo will always be populated as long as a player is found.
    * If no date range is provided, gets all stats without considering date
    * 
    * Requires Authorization:
    * 
    * Claim(s): user, client
    * @param params Request parameters (see {@link StatsGetRequestParams})
    * @return Returns a player's stats
    */
    public get(params: StatsGetRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<PlayerStatsDTO>> {
        const {
            key, 
            ruleset, 
            dateMin, 
            dateMax
        } = params;

        let url_ = this.baseUrl + "/api/v1/stats/{key}?";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        if (ruleset === null)
            throw new Error("The parameter 'ruleset' cannot be null.");
        else if (ruleset !== undefined)
            url_ += "ruleset=" + encodeURIComponent("" + ruleset) + "&";
        if (dateMin === null)
            throw new Error("The parameter 'dateMin' cannot be null.");
        else if (dateMin !== undefined)
            url_ += "dateMin=" + encodeURIComponent(dateMin ? "" + dateMin.toISOString() : "") + "&";
        if (dateMax === null)
            throw new Error("The parameter 'dateMax' cannot be null.");
        else if (dateMax !== undefined)
            url_ += "dateMax=" + encodeURIComponent(dateMax ? "" + dateMax.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<OtrApiResponse<PlayerStatsDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a player does not exist", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlayerStatsDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<PlayerStatsDTO>>(new OtrApiResponse<PlayerStatsDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<PlayerStatsDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Undocumented
    *
    * Requires Authorization:
    * 
    * Claim(s): user, client
    * @param params Request parameters (see {@link StatsGetRatingHistogramRequestParams})
    * @return Success
    */
    public getRatingHistogram(params: StatsGetRatingHistogramRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<{ [key: string]: number; }>> {
        const {
            ruleset
        } = params;

        let url_ = this.baseUrl + "/api/v1/stats/histogram?";
        if (ruleset === null)
            throw new Error("The parameter 'ruleset' cannot be null.");
        else if (ruleset !== undefined)
            url_ += "ruleset=" + encodeURIComponent("" + ruleset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRatingHistogram(_response);
        });
    }

    protected processGetRatingHistogram(response: AxiosResponse): Promise<OtrApiResponse<{ [key: string]: number; }>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OtrApiResponse<{ [key: string]: number; }>>(new OtrApiResponse<{ [key: string]: number; }>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<{ [key: string]: number; }>>(new OtrApiResponse(status, _headers, null as any));
    }
}

/**
* Request parameters available for use when requesting {@link TournamentsWrapper.prototype.createAdminNote | api/v1/tournaments/[id]/notes}
*/
export type TournamentsCreateAdminNoteRequestParams = {
    /**
    * (required) Tournament id
    */
    id: number;
    /**
    * (optional) 
    */
    body?: string | undefined;
}

/**
* Request parameters available for use when requesting {@link TournamentsWrapper.prototype.listAdminNotes | api/v1/tournaments/[id]/notes}
*/
export type TournamentsListAdminNotesRequestParams = {
    /**
    * (required) Tournament id
    */
    id: number;
}

/**
* Request parameters available for use when requesting {@link TournamentsWrapper.prototype.updateAdminNote | api/v1/tournaments/[id]/notes/[noteId]}
*/
export type TournamentsUpdateAdminNoteRequestParams = {
    /**
    * (required) Tournament id
    */
    id: number;
    /**
    * (required) Admin note id
    */
    noteId: number;
    /**
    * (optional) 
    */
    body?: string | undefined;
}

/**
* Request parameters available for use when requesting {@link TournamentsWrapper.prototype.deleteAdminNote | api/v1/tournaments/[id]/notes/[noteId]}
*/
export type TournamentsDeleteAdminNoteRequestParams = {
    /**
    * (required) Tournament id
    */
    id: number;
    /**
    * (required) Admin note id
    */
    noteId: number;
}

/**
* Request parameters available for use when requesting {@link TournamentsWrapper.prototype.list | api/v1/tournaments}
*/
export type TournamentsListRequestParams = {
    /**
    * (required) The page number
    */
    page: number;
    /**
    * (required) The size of the page
    */
    pageSize: number;
    /**
    * (optional) Whether the tournaments must be verified
    */
    verified?: boolean | undefined;
    /**
    * (optional) An optional ruleset to filter by
    */
    ruleset?: Ruleset | undefined;
    /**
    * (optional) The key used to sort results by
    */
    querySortType?: TournamentQuerySortType | undefined;
    /**
    * (optional) Whether the tournaments are sorted in descending order by the API.DTOs.TournamentRequestQueryDTO.QuerySortType
    */
    descending?: boolean | undefined;
}

/**
* Request parameters available for use when requesting {@link TournamentsWrapper.prototype.create | api/v1/tournaments}
*/
export type TournamentsCreateRequestParams = {
    /**
    * (optional) Tournament submission data
    */
    body?: TournamentSubmissionDTO | undefined;
}

/**
* Request parameters available for use when requesting {@link TournamentsWrapper.prototype.get | api/v1/tournaments/[id]}
*/
export type TournamentsGetRequestParams = {
    /**
    * (required) Tournament id
    */
    id: number;
    /**
    * (optional) If true, specifically includes verified match data. If false,
	* includes all data, regardless of verification status.
	* Also includes all child navigations if false.
	* Default true (strictly verified data with limited navigation properties)
    */
    verified?: boolean | undefined;
}

/**
* Request parameters available for use when requesting {@link TournamentsWrapper.prototype.update | api/v1/tournaments/[id]}
*/
export type TournamentsUpdateRequestParams = {
    /**
    * (required) The tournament id
    */
    id: number;
    /**
    * (optional) JsonPatch data
    */
    body?: Operation[] | undefined;
}

/**
* Request parameters available for use when requesting {@link TournamentsWrapper.prototype.delete | api/v1/tournaments/[id]}
*/
export type TournamentsDeleteRequestParams = {
    /**
    * (required) Tournament id
    */
    id: number;
}

/**
* Request parameters available for use when requesting {@link TournamentsWrapper.prototype.listMatches | api/v1/tournaments/[id]/matches}
*/
export type TournamentsListMatchesRequestParams = {
    /**
    * (required) Tournament id
    */
    id: number;
}

export class TournamentsWrapper extends OtrApiWrapperBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: IOtrApiWrapperConfiguration) {

        super(configuration);

        this.instance = axios.create(this.configuration.clientConfiguration);
        this.baseUrl = this.getBaseUrl("");

        if (this.configuration.postConfigureClientMethod) {
            this.configuration.postConfigureClientMethod(this.instance);
        }
    }

    /**
    * Creates an admin note for a tournament
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link TournamentsCreateAdminNoteRequestParams})
    * @return Returns the created admin note
    */
    public createAdminNote(params: TournamentsCreateAdminNoteRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO>> {
        const {
            id, 
            body
        } = params;

        let url_ = this.baseUrl + "/api/v1/tournaments/{id}/notes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateAdminNote(_response);
        });
    }

    protected processCreateAdminNote(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("If the requester is not properly authorized", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a tournament matching the given id does not exist", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the authorized user does not exist", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdminNoteDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse<AdminNoteDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * List all admin notes from a tournament
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link TournamentsListAdminNotesRequestParams})
    * @return Returns all admin notes from a tournament
    */
    public listAdminNotes(params: TournamentsListAdminNotesRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO[]>> {
        const {
            id
        } = params;

        let url_ = this.baseUrl + "/api/v1/tournaments/{id}/notes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListAdminNotes(_response);
        });
    }

    protected processListAdminNotes(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO[]>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a tournament matching the given id does not exist", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdminNoteDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OtrApiResponse<AdminNoteDTO[]>>(new OtrApiResponse<AdminNoteDTO[]>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO[]>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Updates an admin note for a tournament
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link TournamentsUpdateAdminNoteRequestParams})
    * @return Returns the updated admin note
    */
    public updateAdminNote(params: TournamentsUpdateAdminNoteRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO>> {
        const {
            id, 
            noteId, 
            body
        } = params;

        let url_ = this.baseUrl + "/api/v1/tournaments/{id}/notes/{noteId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (noteId === undefined || noteId === null)
            throw new Error("The parameter 'noteId' must be defined.");
        url_ = url_.replace("{noteId}", encodeURIComponent("" + noteId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAdminNote(_response);
        });
    }

    protected processUpdateAdminNote(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("If the requester is not properly authorized", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a tournament matching the given id does not exist.\r\nIf an admin note matching the given noteId does not exist", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the requester did not create the admin note", status, _responseText, _headers, result403);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdminNoteDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse<AdminNoteDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Deletes an admin note for a tournament
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link TournamentsDeleteAdminNoteRequestParams})
    * @return Returns the updated admin note
    */
    public deleteAdminNote(params: TournamentsDeleteAdminNoteRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<AdminNoteDTO>> {
        const {
            id, 
            noteId
        } = params;

        let url_ = this.baseUrl + "/api/v1/tournaments/{id}/notes/{noteId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (noteId === undefined || noteId === null)
            throw new Error("The parameter 'noteId' must be defined.");
        url_ = url_.replace("{noteId}", encodeURIComponent("" + noteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAdminNote(_response);
        });
    }

    protected processDeleteAdminNote(response: AxiosResponse): Promise<OtrApiResponse<AdminNoteDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("If the requester is not properly authorized", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a tournament matching the given id does not exist.\r\nIf an admin note matching the given noteId does not exist", status, _responseText, _headers, result404);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AdminNoteDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse<AdminNoteDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<AdminNoteDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Get all tournaments which fit an optional request query
    *
    * Will not include match data
    * @param params Request parameters (see {@link TournamentsListRequestParams})
    * @return Returns all tournaments which fit the request query
    */
    public list(params: TournamentsListRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<TournamentDTO[]>> {
        const {
            page, 
            pageSize, 
            verified, 
            ruleset, 
            querySortType, 
            descending
        } = params;

        let url_ = this.baseUrl + "/api/v1/tournaments?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (verified === null)
            throw new Error("The parameter 'verified' cannot be null.");
        else if (verified !== undefined)
            url_ += "Verified=" + encodeURIComponent("" + verified) + "&";
        if (ruleset === null)
            throw new Error("The parameter 'ruleset' cannot be null.");
        else if (ruleset !== undefined)
            url_ += "Ruleset=" + encodeURIComponent("" + ruleset) + "&";
        if (querySortType === null)
            throw new Error("The parameter 'querySortType' cannot be null.");
        else if (querySortType !== undefined)
            url_ += "QuerySortType=" + encodeURIComponent("" + querySortType) + "&";
        if (descending === null)
            throw new Error("The parameter 'descending' cannot be null.");
        else if (descending !== undefined)
            url_ += "Descending=" + encodeURIComponent("" + descending) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = false

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processList(_response);
        });
    }

    protected processList(response: AxiosResponse): Promise<OtrApiResponse<TournamentDTO[]>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TournamentDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OtrApiResponse<TournamentDTO[]>>(new OtrApiResponse<TournamentDTO[]>(status, _headers, result200));

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<TournamentDTO[]>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Submit a tournament
    *
    * Requires Authorization:
    * 
    * Claim(s): user
    * @param params Request parameters (see {@link TournamentsCreateRequestParams})
    * @return Returns location information for the created tournament
    */
    public create(params: TournamentsCreateRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<TournamentCreatedResultDTO>> {
        const {
            body
        } = params;

        let url_ = this.baseUrl + "/api/v1/tournaments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<OtrApiResponse<TournamentCreatedResultDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the given !:tournamentSubmission is malformed or\r\nif a tournament matching the given name and ruleset already exists", status, _responseText, _headers, result400);

        } else if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = TournamentCreatedResultDTO.fromJS(resultData201);
            return Promise.resolve<OtrApiResponse<TournamentCreatedResultDTO>>(new OtrApiResponse<TournamentCreatedResultDTO>(status, _headers, result201));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<TournamentCreatedResultDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Get a tournament
    *
    * Requires Authorization:
    * 
    * Claim(s): user, client
    * @param params Request parameters (see {@link TournamentsGetRequestParams})
    * @return Returns the tournament
    */
    public get(params: TournamentsGetRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<TournamentDTO>> {
        const {
            id, 
            verified
        } = params;

        let url_ = this.baseUrl + "/api/v1/tournaments/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (verified === null)
            throw new Error("The parameter 'verified' cannot be null.");
        else if (verified !== undefined)
            url_ += "verified=" + encodeURIComponent("" + verified) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<OtrApiResponse<TournamentDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a tournament matching the given id does not exist", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TournamentDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<TournamentDTO>>(new OtrApiResponse<TournamentDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<TournamentDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Amend tournament data
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link TournamentsUpdateRequestParams})
    * @return Returns the patched tournament
    */
    public update(params: TournamentsUpdateRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<TournamentDTO>> {
        const {
            id, 
            body
        } = params;

        let url_ = this.baseUrl + "/api/v1/tournaments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<OtrApiResponse<TournamentDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If the provided id does not belong to a tournament", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("If JsonPatch data is malformed", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TournamentDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<TournamentDTO>>(new OtrApiResponse<TournamentDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<TournamentDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Delete a tournament
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link TournamentsDeleteRequestParams})
    * @return The tournament was deleted successfully
    */
    public delete(params: TournamentsDeleteRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<void>> {
        const {
            id
        } = params;

        let url_ = this.baseUrl + "/api/v1/tournaments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<OtrApiResponse<void>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse<void>(status, _headers, null as any));

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("The tournament does not exist", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * List all matches from a tournament
    *
    * Requires Authorization:
    * 
    * Claim(s): user, client
    * @param params Request parameters (see {@link TournamentsListMatchesRequestParams})
    * @return Returns all matches from a tournament
    */
    public listMatches(params: TournamentsListMatchesRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<MatchDTO[]>> {
        const {
            id
        } = params;

        let url_ = this.baseUrl + "/api/v1/tournaments/{id}/matches";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListMatches(_response);
        });
    }

    protected processListMatches(response: AxiosResponse): Promise<OtrApiResponse<MatchDTO[]>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a tournament matching the given id does not exist", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MatchDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OtrApiResponse<MatchDTO[]>>(new OtrApiResponse<MatchDTO[]>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<MatchDTO[]>>(new OtrApiResponse(status, _headers, null as any));
    }
}

/**
* Request parameters available for use when requesting {@link UsersWrapper.prototype.get | api/v1/users/[id]}
*/
export type UsersGetRequestParams = {
    /**
    * (required) Id of the user
    */
    id: number;
}

/**
* Request parameters available for use when requesting {@link UsersWrapper.prototype.updateScopes | api/v1/users/[id]/scopes}
*/
export type UsersUpdateScopesRequestParams = {
    /**
    * (required) Id of the user
    */
    id: number;
    /**
    * (optional) List of scopes to assign to the user
    */
    body?: string[] | undefined;
}

/**
* Request parameters available for use when requesting {@link UsersWrapper.prototype.getSubmissions | api/v1/users/[id]/submissions}
*/
export type UsersGetSubmissionsRequestParams = {
    /**
    * (required) Id of the user
    */
    id: number;
}

/**
* Request parameters available for use when requesting {@link UsersWrapper.prototype.rejectSubmissions | api/v1/users/[id]/submissions:reject}
*/
export type UsersRejectSubmissionsRequestParams = {
    /**
    * (required) Id of the user
    */
    id: number;
}

/**
* Request parameters available for use when requesting {@link UsersWrapper.prototype.getClients | api/v1/users/[id]/clients}
*/
export type UsersGetClientsRequestParams = {
    /**
    * (required) Id of the user
    */
    id: number;
}

/**
* Request parameters available for use when requesting {@link UsersWrapper.prototype.deleteClient | api/v1/users/[id]/clients/[clientId]}
*/
export type UsersDeleteClientRequestParams = {
    /**
    * (required) Id of the user
    */
    id: number;
    /**
    * (required) Id of the OAuth client
    */
    clientId: number;
}

/**
* Request parameters available for use when requesting {@link UsersWrapper.prototype.resetClientSecret | api/v1/users/[id]/clients/[clientId]/secret:reset}
*/
export type UsersResetClientSecretRequestParams = {
    /**
    * (required) Id of the user
    */
    id: number;
    /**
    * (required) Id of the OAuth client
    */
    clientId: number;
}

/**
* Request parameters available for use when requesting {@link UsersWrapper.prototype.updateRuleset | api/v1/users/[id]/settings/ruleset}
*/
export type UsersUpdateRulesetRequestParams = {
    /**
    * (required) Id of the user
    */
    id: number;
    /**
    * (optional) The new ruleset
    */
    body?: Ruleset | undefined;
}

/**
* Request parameters available for use when requesting {@link UsersWrapper.prototype.syncRuleset | api/v1/users/[id]/settings/ruleset:sync}
*/
export type UsersSyncRulesetRequestParams = {
    /**
    * (required) Id of the user
    */
    id: number;
}

export class UsersWrapper extends OtrApiWrapperBase {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: IOtrApiWrapperConfiguration) {

        super(configuration);

        this.instance = axios.create(this.configuration.clientConfiguration);
        this.baseUrl = this.getBaseUrl("");

        if (this.configuration.postConfigureClientMethod) {
            this.configuration.postConfigureClientMethod(this.instance);
        }
    }

    /**
    * Get a user
    *
    * Requires Authorization:
    * 
    * Policy: AccessUserResources
    * @param params Request parameters (see {@link UsersGetRequestParams})
    * @return Returns a user
    */
    public get(params: UsersGetRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<UserDTO>> {
        const {
            id
        } = params;

        let url_ = this.baseUrl + "/api/v1/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<OtrApiResponse<UserDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a user does not exist", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<UserDTO>>(new OtrApiResponse<UserDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<UserDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Update a user's scopes
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link UsersUpdateScopesRequestParams})
    * @return Returns an updated user
    */
    public updateScopes(params: UsersUpdateScopesRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<UserDTO>> {
        const {
            id, 
            body
        } = params;

        let url_ = this.baseUrl + "/api/v1/users/{id}/scopes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateScopes(_response);
        });
    }

    protected processUpdateScopes(response: AxiosResponse): Promise<OtrApiResponse<UserDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a user does not exist", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If any of the given scopes are invalid, or the update was not successful", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<UserDTO>>(new OtrApiResponse<UserDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<UserDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Get a user's match submissions
    *
    * Requires Authorization:
    * 
    * Policy: AccessUserResources
    * @param params Request parameters (see {@link UsersGetSubmissionsRequestParams})
    * @return Returns a list of submissions
    */
    public getSubmissions(params: UsersGetSubmissionsRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<MatchSubmissionStatusDTO[]>> {
        const {
            id
        } = params;

        let url_ = this.baseUrl + "/api/v1/users/{id}/submissions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSubmissions(_response);
        });
    }

    protected processGetSubmissions(response: AxiosResponse): Promise<OtrApiResponse<MatchSubmissionStatusDTO[]>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a user does not exist", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MatchSubmissionStatusDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OtrApiResponse<MatchSubmissionStatusDTO[]>>(new OtrApiResponse<MatchSubmissionStatusDTO[]>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<MatchSubmissionStatusDTO[]>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Rejects a user's match submissions
    *
    * Requires Authorization:
    * 
    * Claim(s): admin
    * @param params Request parameters (see {@link UsersRejectSubmissionsRequestParams})
    * @return Denotes the operation was successful
    */
    public rejectSubmissions(params: UsersRejectSubmissionsRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<void>> {
        const {
            id
        } = params;

        let url_ = this.baseUrl + "/api/v1/users/{id}/submissions:reject";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRejectSubmissions(_response);
        });
    }

    protected processRejectSubmissions(response: AxiosResponse): Promise<OtrApiResponse<void>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a user does not exist", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse<void>(status, _headers, null as any));

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("If the operation was not successful", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Get a user's OAuth clients
    *
    * All users have access to clients that they own.
    * Admin users have access to clients from any user.
    * 
    * Requires Authorization:
    * 
    * Policy: AccessUserResources
    * @param params Request parameters (see {@link UsersGetClientsRequestParams})
    * @return Returns a list of OAuth clients
    */
    public getClients(params: UsersGetClientsRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<OAuthClientDTO[]>> {
        const {
            id
        } = params;

        let url_ = this.baseUrl + "/api/v1/users/{id}/clients";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetClients(_response);
        });
    }

    protected processGetClients(response: AxiosResponse): Promise<OtrApiResponse<OAuthClientDTO[]>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a user does not exist", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OAuthClientDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OtrApiResponse<OAuthClientDTO[]>>(new OtrApiResponse<OAuthClientDTO[]>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<OAuthClientDTO[]>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Delete a user's OAuth client
    *
    * All users have access to delete clients that they own.
    * Admin users have access to clients from any user.
    * 
    * Requires Authorization:
    * 
    * Policy: AccessUserResources
    * @param params Request parameters (see {@link UsersDeleteClientRequestParams})
    * @return If the deletion was successful
    */
    public deleteClient(params: UsersDeleteClientRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<void>> {
        const {
            id, 
            clientId
        } = params;

        let url_ = this.baseUrl + "/api/v1/users/{id}/clients/{clientId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteClient(_response);
        });
    }

    protected processDeleteClient(response: AxiosResponse): Promise<OtrApiResponse<void>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a user or client does not exist", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the deletion was not successful", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse<void>(status, _headers, null as any));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Reset the secret of a user's OAuth client
    *
    * All users have access to reset secrets of clients that they own.
    * Admin users have access to clients from any user.
    * 
    * Requires Authorization:
    * 
    * Policy: AccessUserResources
    * @param params Request parameters (see {@link UsersResetClientSecretRequestParams})
    * @return Returns new client credentials if the secret reset was successful
    */
    public resetClientSecret(params: UsersResetClientSecretRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<OAuthClientCreatedDTO>> {
        const {
            id, 
            clientId
        } = params;

        let url_ = this.baseUrl + "/api/v1/users/{id}/clients/{clientId}/secret:reset";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResetClientSecret(_response);
        });
    }

    protected processResetClientSecret(response: AxiosResponse): Promise<OtrApiResponse<OAuthClientCreatedDTO>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a user or client does not exist", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the secret reset was not successful", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OAuthClientCreatedDTO.fromJS(resultData200);
            return Promise.resolve<OtrApiResponse<OAuthClientCreatedDTO>>(new OtrApiResponse<OAuthClientCreatedDTO>(status, _headers, result200));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<OAuthClientCreatedDTO>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Update the ruleset of a user
    *
    * Requires Authorization:
    * 
    * Policy: AccessUserResources
    * @param params Request parameters (see {@link UsersUpdateRulesetRequestParams})
    * @return If the operation was successful
    */
    public updateRuleset(params: UsersUpdateRulesetRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<void>> {
        const {
            id, 
            body
        } = params;

        let url_ = this.baseUrl + "/api/v1/users/{id}/settings/ruleset";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRuleset(_response);
        });
    }

    protected processUpdateRuleset(response: AxiosResponse): Promise<OtrApiResponse<void>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a user does not exist", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the operation was not successful", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse<void>(status, _headers, null as any));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse(status, _headers, null as any));
    }

    /**
    * Sync the ruleset of a user with their osu! ruleset
    *
    * Requires Authorization:
    * 
    * Policy: AccessUserResources
    * @param params Request parameters (see {@link UsersSyncRulesetRequestParams})
    * @return If the operation was successful
    */
    public syncRuleset(params: UsersSyncRulesetRequestParams, cancelToken?: CancelToken): Promise<OtrApiResponse<void>> {
        const {
            id
        } = params;

        let url_ = this.baseUrl + "/api/v1/users/{id}/settings/ruleset:sync";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };
        (options_ as any).requiresAuth = true

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSyncRuleset(_response);
        });
    }

    protected processSyncRuleset(response: AxiosResponse): Promise<OtrApiResponse<void>> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If a user does not exist", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the operation was not successful", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse<void>(status, _headers, null as any));

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OtrApiResponse<void>>(new OtrApiResponse(status, _headers, null as any));
    }
}

/** Represents access credentials and their expiry */
export class AccessCredentialsDTO implements IAccessCredentialsDTO {
    /** Access token */
    accessToken?: string | undefined;
    /** Refresh token */
    refreshToken?: string | undefined;
    /** Lifetime of the access token in seconds */
    accessExpiration?: number | undefined;
    /** Lifetime of the refresh token in seconds */
    refreshExpiration?: number | undefined;

    constructor(data?: IAccessCredentialsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.accessExpiration = _data["accessExpiration"];
            this.refreshExpiration = _data["refreshExpiration"];
        }
    }

    static fromJS(data: any): AccessCredentialsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AccessCredentialsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["accessExpiration"] = this.accessExpiration;
        data["refreshExpiration"] = this.refreshExpiration;
        return data;
    }
}

/** Represents access credentials and their expiry */
export interface IAccessCredentialsDTO {
    /** Access token */
    accessToken?: string | undefined;
    /** Refresh token */
    refreshToken?: string | undefined;
    /** Lifetime of the access token in seconds */
    accessExpiration?: number | undefined;
    /** Lifetime of the refresh token in seconds */
    refreshExpiration?: number | undefined;
}

/** Represents a note for an entity created by an admin */
export class AdminNoteDTO implements IAdminNoteDTO {
    /** The id of the admin note */
    id!: number;
    /** Timestamp of creation */
    created!: Date;
    /** Timestamp of the last update, if available */
    updated?: Date | undefined;
    /** Id of the parent entity */
    referenceId!: number;
    /** The admin user that created the note */
    adminUser!: UserCompactDTO;
    /** Content of the note */
    note!: string;

    constructor(data?: IAdminNoteDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.adminUser = new UserCompactDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
            this.referenceId = _data["referenceId"];
            this.adminUser = _data["adminUser"] ? UserCompactDTO.fromJS(_data["adminUser"]) : new UserCompactDTO();
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): AdminNoteDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AdminNoteDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["referenceId"] = this.referenceId;
        data["adminUser"] = this.adminUser ? this.adminUser.toJSON() : <any>undefined;
        data["note"] = this.note;
        return data;
    }
}

/** Represents a note for an entity created by an admin */
export interface IAdminNoteDTO {
    /** The id of the admin note */
    id: number;
    /** Timestamp of creation */
    created: Date;
    /** Timestamp of the last update, if available */
    updated?: Date | undefined;
    /** Id of the parent entity */
    referenceId: number;
    /** The admin user that created the note */
    adminUser: UserCompactDTO;
    /** Content of the note */
    note: string;
}

/** Represents an aggregate of match statistics for a player during a period of time */
export class AggregatePlayerMatchStatsDTO implements IAggregatePlayerMatchStatsDTO {
    /** The player's average match cost during the period */
    averageMatchCostAggregate!: number;
    /** The peak rating achieved by the player during the period */
    highestRating!: number;
    /** The amount of rating gained from the start of the period to the end of the period */
    ratingGained!: number;
    /** The amount of games won during the period */
    gamesWon!: number;
    /** The amount of games lost during the period */
    gamesLost!: number;
    /** The amount of games played during the period */
    gamesPlayed!: number;
    /** The amount of matches won during the period */
    matchesWon!: number;
    /** The amount of matches lost during the period */
    matchesLost!: number;
    /** The amount of matches played during the period */
    readonly matchesPlayed!: number;
    /** A value between 0 and 1 representing the player's game win rate during the period */
    readonly gameWinRate!: number;
    /** A value between 0 and 1 representing the player's match win rate during the period */
    readonly matchWinRate!: number;
    /** The average rating of the player's teammates during the period. This average does not include the player's own rating */
    averageTeammateRating?: number | undefined;
    /** The average rating of the player's opponents during the period */
    averageOpponentRating?: number | undefined;
    /** The most amount of matches won in a row during the period */
    bestWinStreak!: number;
    /** Across all matches the player has played in, the average score across the entire lobby. This average includes
scores for games the player may have not been in for */
    matchAverageScoreAggregate!: number;
    /** Across all matches the player has played in, the average miss count of the lobby, across all games in that match */
    matchAverageMissesAggregate!: number;
    /** Across all matches the player has played in, the average accuracy of the lobby, across all games in that match */
    matchAverageAccuracyAggregate!: number;
    /** The amount of maps the player participates in, on average. */
    averageGamesPlayedAggregate!: number;
    /** The average lobby ranking the player has on maps they participate in.
A top-score is 1, bottom score would be team size * 2 */
    averagePlacingAggregate!: number;
    /** The beginning of the period for which the statistics are calculated. */
    periodStart!: Date;
    /** The end of the period for which the statistics are calculated. */
    periodEnd!: Date;

    constructor(data?: IAggregatePlayerMatchStatsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.averageMatchCostAggregate = _data["averageMatchCostAggregate"];
            this.highestRating = _data["highestRating"];
            this.ratingGained = _data["ratingGained"];
            this.gamesWon = _data["gamesWon"];
            this.gamesLost = _data["gamesLost"];
            this.gamesPlayed = _data["gamesPlayed"];
            this.matchesWon = _data["matchesWon"];
            this.matchesLost = _data["matchesLost"];
            (<any>this).matchesPlayed = _data["matchesPlayed"];
            (<any>this).gameWinRate = _data["gameWinRate"];
            (<any>this).matchWinRate = _data["matchWinRate"];
            this.averageTeammateRating = _data["averageTeammateRating"];
            this.averageOpponentRating = _data["averageOpponentRating"];
            this.bestWinStreak = _data["bestWinStreak"];
            this.matchAverageScoreAggregate = _data["matchAverageScoreAggregate"];
            this.matchAverageMissesAggregate = _data["matchAverageMissesAggregate"];
            this.matchAverageAccuracyAggregate = _data["matchAverageAccuracyAggregate"];
            this.averageGamesPlayedAggregate = _data["averageGamesPlayedAggregate"];
            this.averagePlacingAggregate = _data["averagePlacingAggregate"];
            this.periodStart = _data["periodStart"] ? new Date(_data["periodStart"].toString()) : <any>undefined;
            this.periodEnd = _data["periodEnd"] ? new Date(_data["periodEnd"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AggregatePlayerMatchStatsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AggregatePlayerMatchStatsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["averageMatchCostAggregate"] = this.averageMatchCostAggregate;
        data["highestRating"] = this.highestRating;
        data["ratingGained"] = this.ratingGained;
        data["gamesWon"] = this.gamesWon;
        data["gamesLost"] = this.gamesLost;
        data["gamesPlayed"] = this.gamesPlayed;
        data["matchesWon"] = this.matchesWon;
        data["matchesLost"] = this.matchesLost;
        data["matchesPlayed"] = this.matchesPlayed;
        data["gameWinRate"] = this.gameWinRate;
        data["matchWinRate"] = this.matchWinRate;
        data["averageTeammateRating"] = this.averageTeammateRating;
        data["averageOpponentRating"] = this.averageOpponentRating;
        data["bestWinStreak"] = this.bestWinStreak;
        data["matchAverageScoreAggregate"] = this.matchAverageScoreAggregate;
        data["matchAverageMissesAggregate"] = this.matchAverageMissesAggregate;
        data["matchAverageAccuracyAggregate"] = this.matchAverageAccuracyAggregate;
        data["averageGamesPlayedAggregate"] = this.averageGamesPlayedAggregate;
        data["averagePlacingAggregate"] = this.averagePlacingAggregate;
        data["periodStart"] = this.periodStart ? this.periodStart.toISOString() : <any>undefined;
        data["periodEnd"] = this.periodEnd ? this.periodEnd.toISOString() : <any>undefined;
        return data;
    }
}

/** Represents an aggregate of match statistics for a player during a period of time */
export interface IAggregatePlayerMatchStatsDTO {
    /** The player's average match cost during the period */
    averageMatchCostAggregate: number;
    /** The peak rating achieved by the player during the period */
    highestRating: number;
    /** The amount of rating gained from the start of the period to the end of the period */
    ratingGained: number;
    /** The amount of games won during the period */
    gamesWon: number;
    /** The amount of games lost during the period */
    gamesLost: number;
    /** The amount of games played during the period */
    gamesPlayed: number;
    /** The amount of matches won during the period */
    matchesWon: number;
    /** The amount of matches lost during the period */
    matchesLost: number;
    /** The amount of matches played during the period */
    matchesPlayed: number;
    /** A value between 0 and 1 representing the player's game win rate during the period */
    gameWinRate: number;
    /** A value between 0 and 1 representing the player's match win rate during the period */
    matchWinRate: number;
    /** The average rating of the player's teammates during the period. This average does not include the player's own rating */
    averageTeammateRating?: number | undefined;
    /** The average rating of the player's opponents during the period */
    averageOpponentRating?: number | undefined;
    /** The most amount of matches won in a row during the period */
    bestWinStreak: number;
    /** Across all matches the player has played in, the average score across the entire lobby. This average includes
scores for games the player may have not been in for */
    matchAverageScoreAggregate: number;
    /** Across all matches the player has played in, the average miss count of the lobby, across all games in that match */
    matchAverageMissesAggregate: number;
    /** Across all matches the player has played in, the average accuracy of the lobby, across all games in that match */
    matchAverageAccuracyAggregate: number;
    /** The amount of maps the player participates in, on average. */
    averageGamesPlayedAggregate: number;
    /** The average lobby ranking the player has on maps they participate in.
A top-score is 1, bottom score would be team size * 2 */
    averagePlacingAggregate: number;
    /** The beginning of the period for which the statistics are calculated. */
    periodStart: Date;
    /** The end of the period for which the statistics are calculated. */
    periodEnd: Date;
}

/** Represents a beatmap */
export class BeatmapDTO implements IBeatmapDTO {
    /** Id of the beatmap */
    id!: number;
    /** Artist of the song */
    artist!: string;
    /** osu! id of the beatmap */
    osuId!: number;
    /** Beats per minute */
    bpm?: number | undefined;
    /** osu! id of the mapper */
    mapperId!: number;
    /** osu! username of the mapper */
    mapperName!: string;
    /** Star rating */
    sr!: number;
    /** Circle size */
    cs!: number;
    /** Approach rate */
    ar!: number;
    /** Hp */
    hp!: number;
    /** Overall difficulty */
    od!: number;
    /** Song length */
    length!: number;
    /** Title of the beatmap / song */
    title!: string;
    /** Name of the difficulty */
    diffName?: string | undefined;

    constructor(data?: IBeatmapDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.artist = _data["artist"];
            this.osuId = _data["osuId"];
            this.bpm = _data["bpm"];
            this.mapperId = _data["mapperId"];
            this.mapperName = _data["mapperName"];
            this.sr = _data["sr"];
            this.cs = _data["cs"];
            this.ar = _data["ar"];
            this.hp = _data["hp"];
            this.od = _data["od"];
            this.length = _data["length"];
            this.title = _data["title"];
            this.diffName = _data["diffName"];
        }
    }

    static fromJS(data: any): BeatmapDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BeatmapDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["artist"] = this.artist;
        data["osuId"] = this.osuId;
        data["bpm"] = this.bpm;
        data["mapperId"] = this.mapperId;
        data["mapperName"] = this.mapperName;
        data["sr"] = this.sr;
        data["cs"] = this.cs;
        data["ar"] = this.ar;
        data["hp"] = this.hp;
        data["od"] = this.od;
        data["length"] = this.length;
        data["title"] = this.title;
        data["diffName"] = this.diffName;
        return data;
    }
}

/** Represents a beatmap */
export interface IBeatmapDTO {
    /** Id of the beatmap */
    id: number;
    /** Artist of the song */
    artist: string;
    /** osu! id of the beatmap */
    osuId: number;
    /** Beats per minute */
    bpm?: number | undefined;
    /** osu! id of the mapper */
    mapperId: number;
    /** osu! username of the mapper */
    mapperName: string;
    /** Star rating */
    sr: number;
    /** Circle size */
    cs: number;
    /** Approach rate */
    ar: number;
    /** Hp */
    hp: number;
    /** Overall difficulty */
    od: number;
    /** Song length */
    length: number;
    /** Title of the beatmap / song */
    title: string;
    /** Name of the difficulty */
    diffName?: string | undefined;
}

/** Represents data for constructing Microsoft.AspNetCore.Mvc.CreatedResult */
export class CreatedAtRouteValues implements ICreatedAtRouteValues {
    /** Any route or query parameters that must be included in the URI */
    routeValues?: any | undefined;
    /** The controller method that produces the resource */
    action?: string | undefined;
    /** The controller that produces the resource */
    controller?: string | undefined;

    constructor(data?: ICreatedAtRouteValues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.routeValues = _data["routeValues"];
            this.action = _data["action"];
            this.controller = _data["controller"];
        }
    }

    static fromJS(data: any): CreatedAtRouteValues {
        data = typeof data === 'object' ? data : {};
        let result = new CreatedAtRouteValues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["routeValues"] = this.routeValues;
        data["action"] = this.action;
        data["controller"] = this.controller;
        return data;
    }
}

/** Represents data for constructing Microsoft.AspNetCore.Mvc.CreatedResult */
export interface ICreatedAtRouteValues {
    /** Any route or query parameters that must be included in the URI */
    routeValues?: any | undefined;
    /** The controller method that produces the resource */
    action?: string | undefined;
    /** The controller that produces the resource */
    controller?: string | undefined;
}

/** Represents a newly created resource */
export class CreatedResultBaseDTO implements ICreatedResultBaseDTO {
    /** Id of the resource */
    id!: number;
    /** URL of where the new resource can be accessed */
    location!: string;

    constructor(data?: ICreatedResultBaseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.location = _data["location"];
        }
    }

    static fromJS(data: any): CreatedResultBaseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CreatedResultBaseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["location"] = this.location;
        return data;
    }
}

/** Represents a newly created resource */
export interface ICreatedResultBaseDTO {
    /** Id of the resource */
    id: number;
    /** URL of where the new resource can be accessed */
    location: string;
}

/**
* Explains why the player failed filtering
*
* Bitwise flag
*/
export enum FilteringFailReason {
    /** The player passed filtering, thus there is no failure reason */
    None = 0,
    /** The player does not have a rating / profile in the o!TR database */
    NoData = 1,
    /** The player's rating is below the minimum threshold */
    MinRating = 2,
    /** The player's rating is above the maximum threshold */
    MaxRating = 4,
    /**
    * The player is provisional and the filtering criteria specifies
	* exclusion of provisional players
    */
    IsProvisional = 8,
    /**
    * The player has not played in the minimum specified
	* amount of tournaments
    */
    NotEnoughTournaments = 16,
    /** The player's all-time peak rating is above the maximum allowed */
    PeakRatingTooHigh = 32,
    /** The player has not played in the minimum specified amount of matches */
    NotEnoughMatches = 64,
}

/** Represents a set of criteria used by the API.Controllers.FilteringController to determine player eligibility for a tournament */
export class FilteringRequestDTO implements IFilteringRequestDTO {
    /** Represents osu! play modes */
    ruleset!: Ruleset;
    /** Players with a current rating below this value will be filtered */
    minRating?: number | undefined;
    /** Players with a current rating above this value will be filtered */
    maxRating?: number | undefined;
    /** Whether to filter players that currently have a provisional rating */
    allowProvisional!: boolean;
    /** If set, requires players to have participated in at least
this many distinct tournaments */
    tournamentsPlayed?: number | undefined;
    /** If set, requires players to have an all-time peak rating less than
this value */
    peakRating?: number | undefined;
    /** If set, requires players to have played in at least
this many matches */
    matchesPlayed?: number | undefined;
    /** A list of osu! player ids that will be filtered */
    osuPlayerIds!: number[];

    constructor(data?: IFilteringRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.osuPlayerIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ruleset = _data["ruleset"];
            this.minRating = _data["minRating"];
            this.maxRating = _data["maxRating"];
            this.allowProvisional = _data["allowProvisional"];
            this.tournamentsPlayed = _data["tournamentsPlayed"];
            this.peakRating = _data["peakRating"];
            this.matchesPlayed = _data["matchesPlayed"];
            if (Array.isArray(_data["osuPlayerIds"])) {
                this.osuPlayerIds = [] as any;
                for (let item of _data["osuPlayerIds"])
                    this.osuPlayerIds!.push(item);
            }
        }
    }

    static fromJS(data: any): FilteringRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FilteringRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleset"] = this.ruleset;
        data["minRating"] = this.minRating;
        data["maxRating"] = this.maxRating;
        data["allowProvisional"] = this.allowProvisional;
        data["tournamentsPlayed"] = this.tournamentsPlayed;
        data["peakRating"] = this.peakRating;
        data["matchesPlayed"] = this.matchesPlayed;
        if (Array.isArray(this.osuPlayerIds)) {
            data["osuPlayerIds"] = [];
            for (let item of this.osuPlayerIds)
                data["osuPlayerIds"].push(item);
        }
        return data;
    }
}

/** Represents a set of criteria used by the API.Controllers.FilteringController to determine player eligibility for a tournament */
export interface IFilteringRequestDTO {
    /** Represents osu! play modes */
    ruleset: Ruleset;
    /** Players with a current rating below this value will be filtered */
    minRating?: number | undefined;
    /** Players with a current rating above this value will be filtered */
    maxRating?: number | undefined;
    /** Whether to filter players that currently have a provisional rating */
    allowProvisional: boolean;
    /** If set, requires players to have participated in at least
this many distinct tournaments */
    tournamentsPlayed?: number | undefined;
    /** If set, requires players to have an all-time peak rating less than
this value */
    peakRating?: number | undefined;
    /** If set, requires players to have played in at least
this many matches */
    matchesPlayed?: number | undefined;
    /** A list of osu! player ids that will be filtered */
    osuPlayerIds: number[];
}

/** Indicates whether a player passed or failed filtering */
export enum FilteringResult {
    /** Indicates the player passed filtering */
    Pass = 0,
    /** Indicates the player failed filtering */
    Fail = 1,
}

/** Represents a filterings result for a collection of players */
export class FilteringResultDTO implements IFilteringResultDTO {
    /** The number of players who passed filtering */
    playersPassed!: number;
    /** The number of players who failed filtering */
    playersFailed!: number;
    /** A collection of filtering results, one per submitted player,
in the same order as submitted in the API.DTOs.FilteringRequestDTO */
    filteringResults!: PlayerFilteringResultDTO[];

    constructor(data?: IFilteringResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.filteringResults = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playersPassed = _data["playersPassed"];
            this.playersFailed = _data["playersFailed"];
            if (Array.isArray(_data["filteringResults"])) {
                this.filteringResults = [] as any;
                for (let item of _data["filteringResults"])
                    this.filteringResults!.push(PlayerFilteringResultDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FilteringResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FilteringResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playersPassed"] = this.playersPassed;
        data["playersFailed"] = this.playersFailed;
        if (Array.isArray(this.filteringResults)) {
            data["filteringResults"] = [];
            for (let item of this.filteringResults)
                data["filteringResults"].push(item.toJSON());
        }
        return data;
    }
}

/** Represents a filterings result for a collection of players */
export interface IFilteringResultDTO {
    /** The number of players who passed filtering */
    playersPassed: number;
    /** The number of players who failed filtering */
    playersFailed: number;
    /** A collection of filtering results, one per submitted player,
in the same order as submitted in the API.DTOs.FilteringRequestDTO */
    filteringResults: PlayerFilteringResultDTO[];
}

/** Represents a single game (osu! beatmap) played in a match */
export class GameDTO implements IGameDTO {
    /** Primary key */
    id!: number;
    /** Represents osu! play modes */
    ruleset!: Ruleset;
    /** Represents the scoring method (win condition) for a Database.Entities.Game */
    scoringType!: ScoringType;
    /** Represents the team type used for a Database.Entities.Game (See <a href="https://osu.ppy.sh/wiki/en/Client/Interface/Multiplayer"> osu! wiki - Multiplayer</a>) */
    teamType!: TeamType;
    /** Represents mod values */
    mods!: Mods;
    /** osu! id */
    osuId!: number;
    /** The verification status of a Database.Entities.Tournament,
Database.Entities.Match, Database.Entities.Game, or Database.Entities.GameScore */
    verificationStatus!: VerificationStatus;
    /** The status of a Database.Entities.Game in the processing flow */
    processingStatus!: GameProcessingStatus;
    /** Warnings for irregularities in Database.Entities.Game data that don't warrant an automatic
Database.Enums.Verification.VerificationStatus of Database.Enums.Verification.VerificationStatus.PreRejected
but should have attention drawn to them during manual review */
    warningFlags!: GameWarningFlags;
    /** The reason why a Database.Entities.Game is rejected */
    rejectionReason!: GameRejectionReason;
    /** Timestamp of the beginning of the game */
    startTime!: Date;
    /** Timestamp of the end of the game */
    endTime?: Date | undefined;
    /** The beatmap played */
    beatmap?: BeatmapDTO | undefined;
    /** All associated admin notes */
    adminNotes!: AdminNoteDTO[];
    /** All match scores */
    scores!: GameScoreDTO[];

    constructor(data?: IGameDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.adminNotes = [];
            this.scores = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ruleset = _data["ruleset"];
            this.scoringType = _data["scoringType"];
            this.teamType = _data["teamType"];
            this.mods = _data["mods"];
            this.osuId = _data["osuId"];
            this.verificationStatus = _data["verificationStatus"];
            this.processingStatus = _data["processingStatus"];
            this.warningFlags = _data["warningFlags"];
            this.rejectionReason = _data["rejectionReason"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.beatmap = _data["beatmap"] ? BeatmapDTO.fromJS(_data["beatmap"]) : <any>undefined;
            if (Array.isArray(_data["adminNotes"])) {
                this.adminNotes = [] as any;
                for (let item of _data["adminNotes"])
                    this.adminNotes!.push(AdminNoteDTO.fromJS(item));
            }
            if (Array.isArray(_data["scores"])) {
                this.scores = [] as any;
                for (let item of _data["scores"])
                    this.scores!.push(GameScoreDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GameDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GameDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ruleset"] = this.ruleset;
        data["scoringType"] = this.scoringType;
        data["teamType"] = this.teamType;
        data["mods"] = this.mods;
        data["osuId"] = this.osuId;
        data["verificationStatus"] = this.verificationStatus;
        data["processingStatus"] = this.processingStatus;
        data["warningFlags"] = this.warningFlags;
        data["rejectionReason"] = this.rejectionReason;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["beatmap"] = this.beatmap ? this.beatmap.toJSON() : <any>undefined;
        if (Array.isArray(this.adminNotes)) {
            data["adminNotes"] = [];
            for (let item of this.adminNotes)
                data["adminNotes"].push(item.toJSON());
        }
        if (Array.isArray(this.scores)) {
            data["scores"] = [];
            for (let item of this.scores)
                data["scores"].push(item.toJSON());
        }
        return data;
    }
}

/** Represents a single game (osu! beatmap) played in a match */
export interface IGameDTO {
    /** Primary key */
    id: number;
    /** Represents osu! play modes */
    ruleset: Ruleset;
    /** Represents the scoring method (win condition) for a Database.Entities.Game */
    scoringType: ScoringType;
    /** Represents the team type used for a Database.Entities.Game (See <a href="https://osu.ppy.sh/wiki/en/Client/Interface/Multiplayer"> osu! wiki - Multiplayer</a>) */
    teamType: TeamType;
    /** Represents mod values */
    mods: Mods;
    /** osu! id */
    osuId: number;
    /** The verification status of a Database.Entities.Tournament,
Database.Entities.Match, Database.Entities.Game, or Database.Entities.GameScore */
    verificationStatus: VerificationStatus;
    /** The status of a Database.Entities.Game in the processing flow */
    processingStatus: GameProcessingStatus;
    /** Warnings for irregularities in Database.Entities.Game data that don't warrant an automatic
Database.Enums.Verification.VerificationStatus of Database.Enums.Verification.VerificationStatus.PreRejected
but should have attention drawn to them during manual review */
    warningFlags: GameWarningFlags;
    /** The reason why a Database.Entities.Game is rejected */
    rejectionReason: GameRejectionReason;
    /** Timestamp of the beginning of the game */
    startTime: Date;
    /** Timestamp of the end of the game */
    endTime?: Date | undefined;
    /** The beatmap played */
    beatmap?: BeatmapDTO | undefined;
    /** All associated admin notes */
    adminNotes: AdminNoteDTO[];
    /** All match scores */
    scores: GameScoreDTO[];
}

/** The status of a Database.Entities.Game in the processing flow */
export enum GameProcessingStatus {
    /** The Database.Entities.Game needs automation checks */
    NeedsAutomationChecks = 0,
    /**
    * The Database.Entities.Game is awaiting verification from a
	* Database.Entities.User with verifier permission
    */
    NeedsVerification = 1,
    /**
    * The Database.Entities.Game needs stat calculation
	* 
	* Generates the Database.Entities.GameWinRecord
    */
    NeedsStatCalculation = 2,
    /** The Database.Entities.Game has completed all processing steps */
    Done = 3,
}

/**
* The reason why a Database.Entities.Game is rejected
*
* Bitwise flag
*/
export enum GameRejectionReason {
    /** The Database.Entities.Game is not rejected */
    None = 0,
    /** The Database.Entities.Game's osu! API data did not contain any Database.Entities.GameScores */
    NoScores = 1,
    /** The Database.Entities.Game has invalid mods applied */
    InvalidMods = 2,
    /** The Database.Entities.Game's Database.Enums.Ruleset does not match that of the parent Database.Entities.Tournament */
    RulesetMismatch = 4,
    /** The Database.Entities.Game's Database.Enums.ScoringType is not Database.Enums.ScoringType.ScoreV2 */
    InvalidScoringType = 8,
    /** The Database.Entities.Game's Database.Enums.TeamType is not Database.Enums.TeamType.TeamVs */
    InvalidTeamType = 16,
    /**
    * The Database.Entities.Game's Database.Enums.TeamType is not Database.Enums.TeamType.TeamVs
	* and attempting Database.Enums.TeamType.TeamVs conversion was not successful
    */
    FailedTeamVsConversion = 32,
    /**
    * The Database.Entities.Game's number of Database.Entities.Game.Scores with a Database.Enums.Verification.VerificationStatus
	* of Database.Enums.Verification.VerificationStatus.Verified or Database.Enums.Verification.VerificationStatus.PreVerified is < 2
    */
    NoValidScores = 64,
    /**
    * The Database.Entities.Game's number of Database.Entities.Game.Scores with a Database.Enums.Verification.VerificationStatus
	* of Database.Enums.Verification.VerificationStatus.Verified or Database.Enums.Verification.VerificationStatus.PreVerified divided by 2 is
	* not equal to the Database.Entities.Tournament.LobbySize of the parent Database.Entities.Tournament
    */
    LobbySizeMismatch = 128,
    /** The Database.Entities.Game's Database.Entities.Game.EndTime could not be determined */
    NoEndTime = 256,
    /** The Database.Entities.Match the Database.Entities.Game was played in was rejected */
    RejectedMatch = 512,
}

export class GameScoreDTO implements IGameScoreDTO {
    /** The id of the Player this score belongs to */
    playerId!: number;
    /** Represents the team a Database.Entities.Player was on when a Database.Entities.GameScore was set */
    team!: Team;
    /** The points earned */
    score!: number;
    /** Represents mod values */
    mods!: Mods;
    /** The number of missed notes */
    misses!: number;
    /** The verification status of a Database.Entities.Tournament,
Database.Entities.Match, Database.Entities.Game, or Database.Entities.GameScore */
    verificationStatus!: VerificationStatus;
    /** The status of a Database.Entities.GameScore in the processing flow */
    processingStatus!: ScoreProcessingStatus;
    /** The reason why a Database.Entities.GameScore is rejected */
    rejectionReason!: ScoreRejectionReason;
    /** The accuracy of the score */
    accuracy!: number;
    /** All associated admin notes */
    adminNotes!: AdminNoteDTO[];

    constructor(data?: IGameScoreDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.adminNotes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playerId = _data["playerId"];
            this.team = _data["team"];
            this.score = _data["score"];
            this.mods = _data["mods"];
            this.misses = _data["misses"];
            this.verificationStatus = _data["verificationStatus"];
            this.processingStatus = _data["processingStatus"];
            this.rejectionReason = _data["rejectionReason"];
            this.accuracy = _data["accuracy"];
            if (Array.isArray(_data["adminNotes"])) {
                this.adminNotes = [] as any;
                for (let item of _data["adminNotes"])
                    this.adminNotes!.push(AdminNoteDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GameScoreDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GameScoreDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playerId"] = this.playerId;
        data["team"] = this.team;
        data["score"] = this.score;
        data["mods"] = this.mods;
        data["misses"] = this.misses;
        data["verificationStatus"] = this.verificationStatus;
        data["processingStatus"] = this.processingStatus;
        data["rejectionReason"] = this.rejectionReason;
        data["accuracy"] = this.accuracy;
        if (Array.isArray(this.adminNotes)) {
            data["adminNotes"] = [];
            for (let item of this.adminNotes)
                data["adminNotes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGameScoreDTO {
    /** The id of the Player this score belongs to */
    playerId: number;
    /** Represents the team a Database.Entities.Player was on when a Database.Entities.GameScore was set */
    team: Team;
    /** The points earned */
    score: number;
    /** Represents mod values */
    mods: Mods;
    /** The number of missed notes */
    misses: number;
    /** The verification status of a Database.Entities.Tournament,
Database.Entities.Match, Database.Entities.Game, or Database.Entities.GameScore */
    verificationStatus: VerificationStatus;
    /** The status of a Database.Entities.GameScore in the processing flow */
    processingStatus: ScoreProcessingStatus;
    /** The reason why a Database.Entities.GameScore is rejected */
    rejectionReason: ScoreRejectionReason;
    /** The accuracy of the score */
    accuracy: number;
    /** All associated admin notes */
    adminNotes: AdminNoteDTO[];
}

/**
* Warnings for irregularities in Database.Entities.Game data that don't warrant an automatic Database.Enums.Verification.VerificationStatus of Database.Enums.Verification.VerificationStatus.PreRejected but should have attention drawn to them during manual review
*
* Bitwise flag
*/
export enum GameWarningFlags {
    /** The Database.Entities.Game has no warnings */
    None = 0,
    /**
    * If the parent Database.Entities.Tournament does not have a submitted pool of
	* Database.Entities.Beatmaps, and the Database.Entities.Game's Database.Entities.Game.Beatmap
	* is played only once throughout the entire Database.Entities.Tournament
    */
    BeatmapUsedOnce = 1,
    /**
    * If the parent Database.Entities.Tournament has a submitted pool of Database.Entities.Beatmaps,
	* the Database.Entities.Game's Database.Entities.Game.Beatmap is not a part of the pool,
	* and the Database.Entities.Game is not one of the first two in the Database.Entities.Match
    */
    BeatmapNotInMappool = 2,
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class HttpValidationProblemDetails extends ProblemDetails implements IHttpValidationProblemDetails {
    errors!: { [key: string]: string[]; };

    [key: string]: any;

    constructor(data?: IHttpValidationProblemDetails) {
        super(data);
        if (!data) {
            this.errors = {};
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static override fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHttpValidationProblemDetails extends IProblemDetails {
    errors: { [key: string]: string[]; };

    [key: string]: any;
}

export enum LeaderboardChartType {
    Global = 0,
    Country = 1,
}

export class LeaderboardDTO implements ILeaderboardDTO {
    /** Represents osu! play modes */
    ruleset!: Ruleset;
    totalPlayerCount!: number;
    filterDefaults!: LeaderboardFilterDefaultsDTO;
    leaderboard!: LeaderboardPlayerInfoDTO[];

    constructor(data?: ILeaderboardDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.filterDefaults = new LeaderboardFilterDefaultsDTO();
            this.leaderboard = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ruleset = _data["ruleset"];
            this.totalPlayerCount = _data["totalPlayerCount"];
            this.filterDefaults = _data["filterDefaults"] ? LeaderboardFilterDefaultsDTO.fromJS(_data["filterDefaults"]) : new LeaderboardFilterDefaultsDTO();
            if (Array.isArray(_data["leaderboard"])) {
                this.leaderboard = [] as any;
                for (let item of _data["leaderboard"])
                    this.leaderboard!.push(LeaderboardPlayerInfoDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LeaderboardDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaderboardDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleset"] = this.ruleset;
        data["totalPlayerCount"] = this.totalPlayerCount;
        data["filterDefaults"] = this.filterDefaults ? this.filterDefaults.toJSON() : <any>undefined;
        if (Array.isArray(this.leaderboard)) {
            data["leaderboard"] = [];
            for (let item of this.leaderboard)
                data["leaderboard"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILeaderboardDTO {
    /** Represents osu! play modes */
    ruleset: Ruleset;
    totalPlayerCount: number;
    filterDefaults: LeaderboardFilterDefaultsDTO;
    leaderboard: LeaderboardPlayerInfoDTO[];
}

/** Filters for the leaderboard */
export class LeaderboardFilterDTO implements ILeaderboardFilterDTO {
    /** The "better" inclusive bound (ranges from 1+) */
    minRank?: number | undefined;
    /** The "worse" inclusive bound (ranges from 1+) */
    maxRank?: number | undefined;
    /** The lower-performing rating bound (ranges from 100+) */
    minRating?: number | undefined;
    /** The higher-performing rating bound (ranges from 100+) */
    maxRating?: number | undefined;
    /** The minimum number of matches played (ranges from 1-10000) */
    minMatches?: number | undefined;
    /** The maximum number of matches played (ranges from 1-10000) */
    maxMatches?: number | undefined;
    /** Ranges from 0.00-1.00 */
    minWinRate?: number | undefined;
    /** Ranges from 0.00-1.00 */
    maxWinRate?: number | undefined;
    /** A collection of optional filters for tiers */
    tierFilters?: LeaderboardTierFilterDTO | undefined;

    constructor(data?: ILeaderboardFilterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minRank = _data["minRank"];
            this.maxRank = _data["maxRank"];
            this.minRating = _data["minRating"];
            this.maxRating = _data["maxRating"];
            this.minMatches = _data["minMatches"];
            this.maxMatches = _data["maxMatches"];
            this.minWinRate = _data["minWinRate"];
            this.maxWinRate = _data["maxWinRate"];
            this.tierFilters = _data["tierFilters"] ? LeaderboardTierFilterDTO.fromJS(_data["tierFilters"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LeaderboardFilterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaderboardFilterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minRank"] = this.minRank;
        data["maxRank"] = this.maxRank;
        data["minRating"] = this.minRating;
        data["maxRating"] = this.maxRating;
        data["minMatches"] = this.minMatches;
        data["maxMatches"] = this.maxMatches;
        data["minWinRate"] = this.minWinRate;
        data["maxWinRate"] = this.maxWinRate;
        data["tierFilters"] = this.tierFilters ? this.tierFilters.toJSON() : <any>undefined;
        return data;
    }
}

/** Filters for the leaderboard */
export interface ILeaderboardFilterDTO {
    /** The "better" inclusive bound (ranges from 1+) */
    minRank?: number | undefined;
    /** The "worse" inclusive bound (ranges from 1+) */
    maxRank?: number | undefined;
    /** The lower-performing rating bound (ranges from 100+) */
    minRating?: number | undefined;
    /** The higher-performing rating bound (ranges from 100+) */
    maxRating?: number | undefined;
    /** The minimum number of matches played (ranges from 1-10000) */
    minMatches?: number | undefined;
    /** The maximum number of matches played (ranges from 1-10000) */
    maxMatches?: number | undefined;
    /** Ranges from 0.00-1.00 */
    minWinRate?: number | undefined;
    /** Ranges from 0.00-1.00 */
    maxWinRate?: number | undefined;
    /** A collection of optional filters for tiers */
    tierFilters?: LeaderboardTierFilterDTO | undefined;
}

export class LeaderboardFilterDefaultsDTO implements ILeaderboardFilterDefaultsDTO {
    maxRank!: number;
    maxRating!: number;
    maxMatches!: number;

    constructor(data?: ILeaderboardFilterDefaultsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxRank = _data["maxRank"];
            this.maxRating = _data["maxRating"];
            this.maxMatches = _data["maxMatches"];
        }
    }

    static fromJS(data: any): LeaderboardFilterDefaultsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaderboardFilterDefaultsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxRank"] = this.maxRank;
        data["maxRating"] = this.maxRating;
        data["maxMatches"] = this.maxMatches;
        return data;
    }
}

export interface ILeaderboardFilterDefaultsDTO {
    maxRank: number;
    maxRating: number;
    maxMatches: number;
}

/** Individual line items in the leaderboard */
export class LeaderboardPlayerInfoDTO implements ILeaderboardPlayerInfoDTO {
    playerId!: number;
    osuId!: number;
    globalRank!: number;
    name!: string;
    tier!: string;
    rating!: number;
    matchesPlayed!: number;
    winRate!: number;
    /** Represents osu! play modes */
    ruleset!: Ruleset;
    country?: string | undefined;

    constructor(data?: ILeaderboardPlayerInfoDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playerId = _data["playerId"];
            this.osuId = _data["osuId"];
            this.globalRank = _data["globalRank"];
            this.name = _data["name"];
            this.tier = _data["tier"];
            this.rating = _data["rating"];
            this.matchesPlayed = _data["matchesPlayed"];
            this.winRate = _data["winRate"];
            this.ruleset = _data["ruleset"];
            this.country = _data["country"];
        }
    }

    static fromJS(data: any): LeaderboardPlayerInfoDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaderboardPlayerInfoDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playerId"] = this.playerId;
        data["osuId"] = this.osuId;
        data["globalRank"] = this.globalRank;
        data["name"] = this.name;
        data["tier"] = this.tier;
        data["rating"] = this.rating;
        data["matchesPlayed"] = this.matchesPlayed;
        data["winRate"] = this.winRate;
        data["ruleset"] = this.ruleset;
        data["country"] = this.country;
        return data;
    }
}

/** Individual line items in the leaderboard */
export interface ILeaderboardPlayerInfoDTO {
    playerId: number;
    osuId: number;
    globalRank: number;
    name: string;
    tier: string;
    rating: number;
    matchesPlayed: number;
    winRate: number;
    /** Represents osu! play modes */
    ruleset: Ruleset;
    country?: string | undefined;
}

/** A collection of booleans representing which tiers to filter.            False = Default, no behavioral change True = Explicitly included in leaderboard results            If *all* tiers are set to false, or all tiers are set to true, the leaderboard will return as if no tier filters were applied.            For example, if Bronze and Emerald are true and everything else is false, then only Bronze and Emerald players will show up in the leaderboard (specifically, Bronze III-I and Emerald III-I) */
export class LeaderboardTierFilterDTO implements ILeaderboardTierFilterDTO {
    filterBronze!: boolean;
    filterSilver!: boolean;
    filterGold!: boolean;
    filterPlatinum!: boolean;
    filterEmerald!: boolean;
    filterDiamond!: boolean;
    filterMaster!: boolean;
    filterGrandmaster!: boolean;
    filterEliteGrandmaster!: boolean;

    constructor(data?: ILeaderboardTierFilterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filterBronze = _data["filterBronze"];
            this.filterSilver = _data["filterSilver"];
            this.filterGold = _data["filterGold"];
            this.filterPlatinum = _data["filterPlatinum"];
            this.filterEmerald = _data["filterEmerald"];
            this.filterDiamond = _data["filterDiamond"];
            this.filterMaster = _data["filterMaster"];
            this.filterGrandmaster = _data["filterGrandmaster"];
            this.filterEliteGrandmaster = _data["filterEliteGrandmaster"];
        }
    }

    static fromJS(data: any): LeaderboardTierFilterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeaderboardTierFilterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filterBronze"] = this.filterBronze;
        data["filterSilver"] = this.filterSilver;
        data["filterGold"] = this.filterGold;
        data["filterPlatinum"] = this.filterPlatinum;
        data["filterEmerald"] = this.filterEmerald;
        data["filterDiamond"] = this.filterDiamond;
        data["filterMaster"] = this.filterMaster;
        data["filterGrandmaster"] = this.filterGrandmaster;
        data["filterEliteGrandmaster"] = this.filterEliteGrandmaster;
        return data;
    }
}

/** A collection of booleans representing which tiers to filter.            False = Default, no behavioral change True = Explicitly included in leaderboard results            If *all* tiers are set to false, or all tiers are set to true, the leaderboard will return as if no tier filters were applied.            For example, if Bronze and Emerald are true and everything else is false, then only Bronze and Emerald players will show up in the leaderboard (specifically, Bronze III-I and Emerald III-I) */
export interface ILeaderboardTierFilterDTO {
    filterBronze: boolean;
    filterSilver: boolean;
    filterGold: boolean;
    filterPlatinum: boolean;
    filterEmerald: boolean;
    filterDiamond: boolean;
    filterMaster: boolean;
    filterGrandmaster: boolean;
    filterEliteGrandmaster: boolean;
}

/** Represents a created match */
export class MatchCreatedResultDTO extends CreatedResultBaseDTO implements IMatchCreatedResultDTO {
    /** Represents data for constructing Microsoft.AspNetCore.Mvc.CreatedResult */
    readonly createdAtRouteValues!: CreatedAtRouteValues;
    /** osu! match id */
    osuId!: number;

    constructor(data?: IMatchCreatedResultDTO) {
        super(data);
        if (!data) {
            this.createdAtRouteValues = new CreatedAtRouteValues();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).createdAtRouteValues = _data["createdAtRouteValues"] ? CreatedAtRouteValues.fromJS(_data["createdAtRouteValues"]) : new CreatedAtRouteValues();
            this.osuId = _data["osuId"];
        }
    }

    static override fromJS(data: any): MatchCreatedResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MatchCreatedResultDTO();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAtRouteValues"] = this.createdAtRouteValues ? this.createdAtRouteValues.toJSON() : <any>undefined;
        data["osuId"] = this.osuId;
        super.toJSON(data);
        return data;
    }
}

/** Represents a created match */
export interface IMatchCreatedResultDTO extends ICreatedResultBaseDTO {
    /** Represents data for constructing Microsoft.AspNetCore.Mvc.CreatedResult */
    createdAtRouteValues: CreatedAtRouteValues;
    /** osu! match id */
    osuId: number;
}

/** Represents a played match */
export class MatchDTO implements IMatchDTO {
    /** Id */
    id!: number;
    /** osu! id */
    osuId!: number;
    /** Title of the lobby */
    name!: string;
    /** Represents osu! play modes */
    ruleset!: Ruleset;
    /** Start time */
    startTime?: Date | undefined;
    /** End time */
    endTime?: Date | undefined;
    /** The verification status of a Database.Entities.Tournament,
Database.Entities.Match, Database.Entities.Game, or Database.Entities.GameScore */
    verificationStatus!: VerificationStatus;
    /** The reason why a Database.Entities.Match is rejected */
    rejectionReason!: MatchRejectionReason;
    /** Warnings for irregularities in Database.Entities.Match data that don't warrant an automatic
Database.Enums.Verification.VerificationStatus of Database.Enums.Verification.VerificationStatus.PreRejected
but should have attention drawn to them during manual review */
    warningFlags!: MatchWarningFlags;
    /** The status of a Database.Entities.Match in the processing flow */
    processingStatus!: MatchProcessingStatus;
    /** Timestamp of the last time the match was processed */
    lastProcessingDate!: Date;
    /** The API.DTOs.TournamentCompactDTO this match was played in */
    tournament!: TournamentCompactDTO;
    /** List of games played during the match */
    games!: GameDTO[];
    /** All associated admin notes */
    adminNotes!: AdminNoteDTO[];

    constructor(data?: IMatchDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tournament = new TournamentCompactDTO();
            this.games = [];
            this.adminNotes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.osuId = _data["osuId"];
            this.name = _data["name"];
            this.ruleset = _data["ruleset"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.verificationStatus = _data["verificationStatus"];
            this.rejectionReason = _data["rejectionReason"];
            this.warningFlags = _data["warningFlags"];
            this.processingStatus = _data["processingStatus"];
            this.lastProcessingDate = _data["lastProcessingDate"] ? new Date(_data["lastProcessingDate"].toString()) : <any>undefined;
            this.tournament = _data["tournament"] ? TournamentCompactDTO.fromJS(_data["tournament"]) : new TournamentCompactDTO();
            if (Array.isArray(_data["games"])) {
                this.games = [] as any;
                for (let item of _data["games"])
                    this.games!.push(GameDTO.fromJS(item));
            }
            if (Array.isArray(_data["adminNotes"])) {
                this.adminNotes = [] as any;
                for (let item of _data["adminNotes"])
                    this.adminNotes!.push(AdminNoteDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MatchDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MatchDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["osuId"] = this.osuId;
        data["name"] = this.name;
        data["ruleset"] = this.ruleset;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["verificationStatus"] = this.verificationStatus;
        data["rejectionReason"] = this.rejectionReason;
        data["warningFlags"] = this.warningFlags;
        data["processingStatus"] = this.processingStatus;
        data["lastProcessingDate"] = this.lastProcessingDate ? this.lastProcessingDate.toISOString() : <any>undefined;
        data["tournament"] = this.tournament ? this.tournament.toJSON() : <any>undefined;
        if (Array.isArray(this.games)) {
            data["games"] = [];
            for (let item of this.games)
                data["games"].push(item.toJSON());
        }
        if (Array.isArray(this.adminNotes)) {
            data["adminNotes"] = [];
            for (let item of this.adminNotes)
                data["adminNotes"].push(item.toJSON());
        }
        return data;
    }
}

/** Represents a played match */
export interface IMatchDTO {
    /** Id */
    id: number;
    /** osu! id */
    osuId: number;
    /** Title of the lobby */
    name: string;
    /** Represents osu! play modes */
    ruleset: Ruleset;
    /** Start time */
    startTime?: Date | undefined;
    /** End time */
    endTime?: Date | undefined;
    /** The verification status of a Database.Entities.Tournament,
Database.Entities.Match, Database.Entities.Game, or Database.Entities.GameScore */
    verificationStatus: VerificationStatus;
    /** The reason why a Database.Entities.Match is rejected */
    rejectionReason: MatchRejectionReason;
    /** Warnings for irregularities in Database.Entities.Match data that don't warrant an automatic
Database.Enums.Verification.VerificationStatus of Database.Enums.Verification.VerificationStatus.PreRejected
but should have attention drawn to them during manual review */
    warningFlags: MatchWarningFlags;
    /** The status of a Database.Entities.Match in the processing flow */
    processingStatus: MatchProcessingStatus;
    /** Timestamp of the last time the match was processed */
    lastProcessingDate: Date;
    /** The API.DTOs.TournamentCompactDTO this match was played in */
    tournament: TournamentCompactDTO;
    /** List of games played during the match */
    games: GameDTO[];
    /** All associated admin notes */
    adminNotes: AdminNoteDTO[];
}

/** Represents a paged list of results */
export class MatchDTOPagedResultDTO implements IMatchDTOPagedResultDTO {
    /** Link to the next potential page of results */
    next?: string | undefined;
    /** Link to the previous potential page of results */
    previous?: string | undefined;
    /** Number of results included */
    count!: number;
    /** List of resulting data */
    results!: MatchDTO[];

    constructor(data?: IMatchDTOPagedResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.next = _data["next"];
            this.previous = _data["previous"];
            this.count = _data["count"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(MatchDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MatchDTOPagedResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MatchDTOPagedResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["next"] = this.next;
        data["previous"] = this.previous;
        data["count"] = this.count;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

/** Represents a paged list of results */
export interface IMatchDTOPagedResultDTO {
    /** Link to the next potential page of results */
    next?: string | undefined;
    /** Link to the previous potential page of results */
    previous?: string | undefined;
    /** Number of results included */
    count: number;
    /** List of resulting data */
    results: MatchDTO[];
}

/** The status of a Database.Entities.Match in the processing flow */
export enum MatchProcessingStatus {
    /** The Database.Entities.Match needs data requested from the osu! API */
    NeedsData = 0,
    /** The Database.Entities.Match needs automation checks */
    NeedsAutomationChecks = 1,
    /**
    * The Database.Entities.Match is awaiting verification from a
	* Database.Entities.User with verifier permission
    */
    NeedsVerification = 2,
    /**
    * The Database.Entities.Match needs stat calculation
	* 
	* Generates the Database.Entities.MatchWinRecord and Database.Entities.PlayerMatchStats
    */
    NeedsStatCalculation = 3,
    /**
    * The Database.Entities.Match is awaiting rating processor data
	* 
	* Generates all Database.Entities.Processor.RatingAdjustments
    */
    NeedsRatingProcessorData = 4,
    /** The Database.Entities.Match has completed all processing steps */
    Done = 5,
}

/** Denotes which property a query for !:Database.Entities.Matches will be sorted by */
export enum MatchQuerySortType {
    /** Sort by primary key */
    Id = 0,
    /** Sort by osu! id */
    OsuId = 1,
    /** Sort by start time */
    StartTime = 2,
    /** Sort by end time */
    EndTime = 3,
    /** Sort by creation date */
    Created = 4,
}

/**
* The reason why a Database.Entities.Match is rejected
*
* Bitwise flag
*/
export enum MatchRejectionReason {
    /** The Database.Entities.Match is not rejected */
    None = 0,
    /** The osu! API returned invalid data or no data for the Database.Entities.Match */
    NoData = 1,
    /** The osu! API returned no Database.Entities.Games for the Database.Entities.Match */
    NoGames = 2,
    /**
    * The Database.Entities.Match's Database.Entities.Match.Name does not start with the
	* parent Database.Entities.Tournament's Database.Entities.Tournament.Abbreviation
    */
    NamePrefixMismatch = 4,
    /**
    * The Database.Entities.Match's !:Entities.Games were eligible for Database.Enums.TeamType.TeamVs
	* conversion and attempting Database.Enums.TeamType.TeamVs conversion was not successful
    */
    FailedTeamVsConversion = 8,
    /**
    * The Database.Entities.Match has no Database.Entities.Match.Games with a Database.Enums.Verification.VerificationStatus
	* of Database.Enums.Verification.VerificationStatus.Verified or Database.Enums.Verification.VerificationStatus.PreVerified
    */
    NoValidGames = 16,
    /**
    * The Database.Entities.Match's number of Database.Entities.Match.Games with a Database.Enums.Verification.VerificationStatus
	* of Database.Enums.Verification.VerificationStatus.Verified or Database.Enums.Verification.VerificationStatus.PreVerified is not an odd number
	* (does not satisfy "best of X")
    */
    UnexpectedGameCount = 32,
    /** The Database.Entities.Match's Database.Entities.Match.EndTime could not be determined */
    NoEndTime = 64,
    /** The Database.Entities.Tournament the Database.Entities.Match was played in was rejected */
    RejectedTournament = 128,
}

/** Represents a search result for a match */
export class MatchSearchResultDTO implements IMatchSearchResultDTO {
    /** Id of the match */
    id!: number;
    /** osu! match id of the match */
    osuId!: number;
    /** Name of the match */
    name?: string | undefined;

    constructor(data?: IMatchSearchResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.osuId = _data["osuId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): MatchSearchResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MatchSearchResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["osuId"] = this.osuId;
        data["name"] = this.name;
        return data;
    }
}

/** Represents a search result for a match */
export interface IMatchSearchResultDTO {
    /** Id of the match */
    id: number;
    /** osu! match id of the match */
    osuId: number;
    /** Name of the match */
    name?: string | undefined;
}

/** Represents the status of a submitted match */
export class MatchSubmissionStatusDTO implements IMatchSubmissionStatusDTO {
    /** Id of the match */
    id!: number;
    /** osu! match id of the match */
    osuId!: number;
    /** Lobby title of the match */
    name?: string | undefined;
    /** Current verification status of the match */
    verificationStatus?: VerificationStatus | undefined;
    /** Date that the match was submitted */
    created!: Date;
    /** Date that the match was last updated */
    updated?: Date | undefined;

    constructor(data?: IMatchSubmissionStatusDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.osuId = _data["osuId"];
            this.name = _data["name"];
            this.verificationStatus = _data["verificationStatus"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MatchSubmissionStatusDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MatchSubmissionStatusDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["osuId"] = this.osuId;
        data["name"] = this.name;
        data["verificationStatus"] = this.verificationStatus;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

/** Represents the status of a submitted match */
export interface IMatchSubmissionStatusDTO {
    /** Id of the match */
    id: number;
    /** osu! match id of the match */
    osuId: number;
    /** Lobby title of the match */
    name?: string | undefined;
    /** Current verification status of the match */
    verificationStatus?: VerificationStatus | undefined;
    /** Date that the match was submitted */
    created: Date;
    /** Date that the match was last updated */
    updated?: Date | undefined;
}

/**
* Warnings for irregularities in Database.Entities.Match data that don't warrant an automatic Database.Enums.Verification.VerificationStatus of Database.Enums.Verification.VerificationStatus.PreRejected but should have attention drawn to them during manual review
*
* Bitwise flag
*/
export enum MatchWarningFlags {
    /** The Database.Entities.Match has no warnings */
    None = 0,
    /**
    * The Database.Entities.Match's Database.Entities.Match.Name does not follow common tournament
	* lobby title conventions
    */
    UnexpectedNameFormat = 1,
    /** The Database.Entities.Match's number of Database.Entities.Match.Games is exactly 3 or 4 */
    LowGameCount = 2,
}

/** Represents some information about a player's mod stats. e.g. how many times has the player played/won with some mod? */
export class ModStatsDTO implements IModStatsDTO {
    gamesPlayed!: number;
    gamesWon!: number;
    winRate!: number;
    normalizedAverageScore!: number;

    constructor(data?: IModStatsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gamesPlayed = _data["gamesPlayed"];
            this.gamesWon = _data["gamesWon"];
            this.winRate = _data["winRate"];
            this.normalizedAverageScore = _data["normalizedAverageScore"];
        }
    }

    static fromJS(data: any): ModStatsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ModStatsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gamesPlayed"] = this.gamesPlayed;
        data["gamesWon"] = this.gamesWon;
        data["winRate"] = this.winRate;
        data["normalizedAverageScore"] = this.normalizedAverageScore;
        return data;
    }
}

/** Represents some information about a player's mod stats. e.g. how many times has the player played/won with some mod? */
export interface IModStatsDTO {
    gamesPlayed: number;
    gamesWon: number;
    winRate: number;
    normalizedAverageScore: number;
}

/**
* Represents mod values
*
* Bitwise flag
*/
export enum Mods {
    /** No mods enabled */
    None = 0,
    /** No fail (NF) */
    NoFail = 1,
    /** Easy (EZ) */
    Easy = 2,
    /** Touch Device (TD) */
    TouchDevice = 4,
    /** Hidden (HD) */
    Hidden = 8,
    /** Hard Rock (HR) */
    HardRock = 16,
    /** Sudden Death (SD) */
    SuddenDeath = 32,
    /** Double Time (DT) */
    DoubleTime = 64,
    /** Relax (RX) */
    Relax = 128,
    /** Half Time (HT) */
    HalfTime = 256,
    /**
    * Nightcore (NC)
	* 
	* Only set along with DoubleTime. i.e: NC only gives 576
    */
    Nightcore = 512,
    /** Flashlight (FL) */
    Flashlight = 1024,
    /** Autoplay (AT) */
    Autoplay = 2048,
    /** Spun Out (SO) */
    SpunOut = 4096,
    /**
    * Autopilot (AP)
	* 
	* Autopilot
    */
    Relax2 = 8192,
    /**
    * Perfect (PF)
	* 
	* Only set along with Database.Enums.Mods.SuddenDeath. i.e: PF only gives 16416
    */
    Perfect = 16384,
    /**
    * 4 key (4K)
	* 
	* Applicable only to Database.Enums.Ruleset.ManiaOther
    */
    InvalidMods = 22688,
    /**
    * 5 key (5K)
	* 
	* Applicable only to Database.Enums.Ruleset.ManiaOther
    */
    Key4 = 32768,
    /**
    * 6 key (6K)
	* 
	* Applicable only to Database.Enums.Ruleset.ManiaOther
    */
    Key5 = 65536,
    /**
    * 7 key (7K)
	* 
	* Applicable only to Database.Enums.Ruleset.ManiaOther
    */
    Key6 = 131072,
    /**
    * 8 key (8K)
	* 
	* Applicable only to Database.Enums.Ruleset.ManiaOther
    */
    Key7 = 262144,
    /**
    * Fade In (FI)
	* 
	* Applicable only to Database.Enums.Ruleset.ManiaOther
    */
    Key8 = 524288,
    /**
    * Random (RD)
	* 
	* Applicable only to Database.Enums.Ruleset.ManiaOther
    */
    FadeIn = 1048576,
    /** Cinema (CM) */
    ScoreIncreaseMods = 1049688,
    /** Target Practice (TP) */
    Random = 2097152,
    /**
    * 9 Key (9K)
	* 
	* Applicable only to Database.Enums.Ruleset.ManiaOther
    */
    Cinema = 4194304,
    /**
    * Co-op (CO)
	* 
	* Applicable only to Database.Enums.Ruleset.ManiaOther
    */
    Target = 8388608,
    /**
    * 1 Key (1K)
	* 
	* Applicable only to Database.Enums.Ruleset.ManiaOther
    */
    Key9 = 16777216,
    /**
    * 3 Key (3K)
	* 
	* Applicable only to Database.Enums.Ruleset.ManiaOther
    */
    KeyCoop = 33554432,
    /**
    * 2 Key (2K)
	* 
	* Applicable only to Database.Enums.Ruleset.ManiaOther
    */
    Key1 = 67108864,
    /** Score v2 (SV2) */
    Key3 = 134217728,
    /**
    * Mirror (MR)
	* 
	* Applicable only to Database.Enums.Ruleset.ManiaOther
    */
    Key2 = 268435456,
    /**
    * Denotes mods that are Database.Enums.Ruleset.ManiaOther key modifiers
	* 
	* See https://osu.ppy.sh/wiki/en/Gameplay/Game_modifier/xK
    */
    KeyMod = 521109504,
    /** Denotes mods that are available to use during Free Mod settings */
    FreeModAllowed = 522171579,
    /** Denotes mods that directly impose a modifier on score */
    ScoreV2 = 536870912,
    /** Denotes mods that are ineligible for ratings */
    Mirror = 1073741824,
}

/** Represents an OAuth client */
export class OAuthClientDTO implements IOAuthClientDTO {
    /** Client id of the client */
    clientId!: number;
    /** List of permissions granted to the client */
    scopes!: string[];
    /** Possible rate limit override for the client */
    rateLimitOverride?: number | undefined;

    constructor(data?: IOAuthClientDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.scopes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            this.rateLimitOverride = _data["rateLimitOverride"];
        }
    }

    static fromJS(data: any): OAuthClientDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OAuthClientDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        data["rateLimitOverride"] = this.rateLimitOverride;
        return data;
    }
}

/** Represents an OAuth client */
export interface IOAuthClientDTO {
    /** Client id of the client */
    clientId: number;
    /** List of permissions granted to the client */
    scopes: string[];
    /** Possible rate limit override for the client */
    rateLimitOverride?: number | undefined;
}

/** Represents a created OAuth client (The only time the client secret is available is when a new client is created) */
export class OAuthClientCreatedDTO extends OAuthClientDTO implements IOAuthClientCreatedDTO {
    /** Client secret of the client */
    clientSecret!: string;

    constructor(data?: IOAuthClientCreatedDTO) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.clientSecret = _data["clientSecret"];
        }
    }

    static override fromJS(data: any): OAuthClientCreatedDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OAuthClientCreatedDTO();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientSecret"] = this.clientSecret;
        super.toJSON(data);
        return data;
    }
}

/** Represents a created OAuth client (The only time the client secret is available is when a new client is created) */
export interface IOAuthClientCreatedDTO extends IOAuthClientDTO {
    /** Client secret of the client */
    clientSecret: string;
}

export class OperationBase implements IOperationBase {
    readonly operationType!: OperationType;
    path?: string | undefined;
    op?: string | undefined;
    from?: string | undefined;

    constructor(data?: IOperationBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).operationType = _data["operationType"];
            this.path = _data["path"];
            this.op = _data["op"];
            this.from = _data["from"];
        }
    }

    static fromJS(data: any): OperationBase {
        data = typeof data === 'object' ? data : {};
        let result = new OperationBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationType"] = this.operationType;
        data["path"] = this.path;
        data["op"] = this.op;
        data["from"] = this.from;
        return data;
    }
}

export interface IOperationBase {
    operationType: OperationType;
    path?: string | undefined;
    op?: string | undefined;
    from?: string | undefined;
}

export class Operation extends OperationBase implements IOperation {
    value?: any | undefined;

    constructor(data?: IOperation) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): Operation {
        data = typeof data === 'object' ? data : {};
        let result = new Operation();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IOperation extends IOperationBase {
    value?: any | undefined;
}

export enum OperationType {
    Add = 0,
    Remove = 1,
    Replace = 2,
    Move = 3,
    Copy = 4,
    Test = 5,
    Invalid = 6,
}

export class Operation_1 extends Operation implements IOperation_1 {

    constructor(data?: IOperation_1) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): Operation_1 {
        data = typeof data === 'object' ? data : {};
        let result = new Operation_1();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IOperation_1 extends IOperation {
}

/** Represents player information */
export class PlayerCompactDTO implements IPlayerCompactDTO {
    /** Id */
    id!: number;
    /** osu! id */
    osuId!: number;
    /** osu! username */
    username!: string;
    /** osu! country code */
    country!: string;
    /** Represents osu! play modes */
    ruleset!: Ruleset;
    /** Id of the associated user, if available */
    userId?: number | undefined;

    constructor(data?: IPlayerCompactDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.osuId = _data["osuId"];
            this.username = _data["username"];
            this.country = _data["country"];
            this.ruleset = _data["ruleset"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): PlayerCompactDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerCompactDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["osuId"] = this.osuId;
        data["username"] = this.username;
        data["country"] = this.country;
        data["ruleset"] = this.ruleset;
        data["userId"] = this.userId;
        return data;
    }
}

/** Represents player information */
export interface IPlayerCompactDTO {
    /** Id */
    id: number;
    /** osu! id */
    osuId: number;
    /** osu! username */
    username: string;
    /** osu! country code */
    country: string;
    /** Represents osu! play modes */
    ruleset: Ruleset;
    /** Id of the associated user, if available */
    userId?: number | undefined;
}

/** Represents one player's filtering result */
export class PlayerFilteringResultDTO implements IPlayerFilteringResultDTO {
    /** The id of the player, if found */
    playerId?: number | undefined;
    /** The username of the player, if found */
    username?: string | undefined;
    /** The osu! id of the player */
    osuId!: number;
    /** Indicates whether a player passed or failed filtering */
    filteringResult!: FilteringResult;
    /** If the user failed filtering, the fail reason */
    filteringFailReason?: FilteringFailReason | undefined;
    /** The API.DTOs.PlayerFilteringResultDTO.FilteringResult in string form */
    readonly filteringResultMessage!: string;
    /** The API.DTOs.PlayerFilteringResultDTO.FilteringFailReason in string form */
    readonly filteringFailReasonMessage?: string | undefined;

    constructor(data?: IPlayerFilteringResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playerId = _data["playerId"];
            this.username = _data["username"];
            this.osuId = _data["osuId"];
            this.filteringResult = _data["filteringResult"];
            this.filteringFailReason = _data["filteringFailReason"];
            (<any>this).filteringResultMessage = _data["filteringResultMessage"];
            (<any>this).filteringFailReasonMessage = _data["filteringFailReasonMessage"];
        }
    }

    static fromJS(data: any): PlayerFilteringResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerFilteringResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playerId"] = this.playerId;
        data["username"] = this.username;
        data["osuId"] = this.osuId;
        data["filteringResult"] = this.filteringResult;
        data["filteringFailReason"] = this.filteringFailReason;
        data["filteringResultMessage"] = this.filteringResultMessage;
        data["filteringFailReasonMessage"] = this.filteringFailReasonMessage;
        return data;
    }
}

/** Represents one player's filtering result */
export interface IPlayerFilteringResultDTO {
    /** The id of the player, if found */
    playerId?: number | undefined;
    /** The username of the player, if found */
    username?: string | undefined;
    /** The osu! id of the player */
    osuId: number;
    /** Indicates whether a player passed or failed filtering */
    filteringResult: FilteringResult;
    /** If the user failed filtering, the fail reason */
    filteringFailReason?: FilteringFailReason | undefined;
    /** The API.DTOs.PlayerFilteringResultDTO.FilteringResult in string form */
    filteringResultMessage: string;
    /** The API.DTOs.PlayerFilteringResultDTO.FilteringFailReason in string form */
    filteringFailReasonMessage?: string | undefined;
}

/** Represents a player in the context of a teammate or opponent of another player */
export class PlayerFrequencyDTO implements IPlayerFrequencyDTO {
    /** Id of the teammate or opponent */
    playerId!: number;
    /** osu! id of the teammate or opponent */
    osuId!: number;
    /** osu! username of the teammate or opponent */
    username?: string | undefined;
    /** Number of times this teammate or opponent has played with the player */
    frequency!: number;

    constructor(data?: IPlayerFrequencyDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playerId = _data["playerId"];
            this.osuId = _data["osuId"];
            this.username = _data["username"];
            this.frequency = _data["frequency"];
        }
    }

    static fromJS(data: any): PlayerFrequencyDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerFrequencyDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playerId"] = this.playerId;
        data["osuId"] = this.osuId;
        data["username"] = this.username;
        data["frequency"] = this.frequency;
        return data;
    }
}

/** Represents a player in the context of a teammate or opponent of another player */
export interface IPlayerFrequencyDTO {
    /** Id of the teammate or opponent */
    playerId: number;
    /** osu! id of the teammate or opponent */
    osuId: number;
    /** osu! username of the teammate or opponent */
    username?: string | undefined;
    /** Number of times this teammate or opponent has played with the player */
    frequency: number;
}

/** Represents counts of participation in games of differing mod combinations */
export class PlayerModStatsDTO implements IPlayerModStatsDTO {
    /** Number of games played with no mods */
    playedNM?: ModStatsDTO | undefined;
    /** Number of games played with easy */
    playedEZ?: ModStatsDTO | undefined;
    /** Number of games played with half time */
    playedHT?: ModStatsDTO | undefined;
    /** Number of games played with hidden */
    playedHD?: ModStatsDTO | undefined;
    /** Number of games played with hard rock */
    playedHR?: ModStatsDTO | undefined;
    /** Number of games played with double time */
    playedDT?: ModStatsDTO | undefined;
    /** Number of games played with flashlight */
    playedFL?: ModStatsDTO | undefined;
    /** Number of games played with both hidden and hard rock */
    playedHDHR?: ModStatsDTO | undefined;
    /** Number of games played with both hidden and double time */
    playedHDDT?: ModStatsDTO | undefined;
    /** Number of games played with both hidden and easy */
    playedHDEZ?: ModStatsDTO | undefined;

    constructor(data?: IPlayerModStatsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playedNM = _data["playedNM"] ? ModStatsDTO.fromJS(_data["playedNM"]) : <any>undefined;
            this.playedEZ = _data["playedEZ"] ? ModStatsDTO.fromJS(_data["playedEZ"]) : <any>undefined;
            this.playedHT = _data["playedHT"] ? ModStatsDTO.fromJS(_data["playedHT"]) : <any>undefined;
            this.playedHD = _data["playedHD"] ? ModStatsDTO.fromJS(_data["playedHD"]) : <any>undefined;
            this.playedHR = _data["playedHR"] ? ModStatsDTO.fromJS(_data["playedHR"]) : <any>undefined;
            this.playedDT = _data["playedDT"] ? ModStatsDTO.fromJS(_data["playedDT"]) : <any>undefined;
            this.playedFL = _data["playedFL"] ? ModStatsDTO.fromJS(_data["playedFL"]) : <any>undefined;
            this.playedHDHR = _data["playedHDHR"] ? ModStatsDTO.fromJS(_data["playedHDHR"]) : <any>undefined;
            this.playedHDDT = _data["playedHDDT"] ? ModStatsDTO.fromJS(_data["playedHDDT"]) : <any>undefined;
            this.playedHDEZ = _data["playedHDEZ"] ? ModStatsDTO.fromJS(_data["playedHDEZ"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PlayerModStatsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerModStatsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playedNM"] = this.playedNM ? this.playedNM.toJSON() : <any>undefined;
        data["playedEZ"] = this.playedEZ ? this.playedEZ.toJSON() : <any>undefined;
        data["playedHT"] = this.playedHT ? this.playedHT.toJSON() : <any>undefined;
        data["playedHD"] = this.playedHD ? this.playedHD.toJSON() : <any>undefined;
        data["playedHR"] = this.playedHR ? this.playedHR.toJSON() : <any>undefined;
        data["playedDT"] = this.playedDT ? this.playedDT.toJSON() : <any>undefined;
        data["playedFL"] = this.playedFL ? this.playedFL.toJSON() : <any>undefined;
        data["playedHDHR"] = this.playedHDHR ? this.playedHDHR.toJSON() : <any>undefined;
        data["playedHDDT"] = this.playedHDDT ? this.playedHDDT.toJSON() : <any>undefined;
        data["playedHDEZ"] = this.playedHDEZ ? this.playedHDEZ.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents counts of participation in games of differing mod combinations */
export interface IPlayerModStatsDTO {
    /** Number of games played with no mods */
    playedNM?: ModStatsDTO | undefined;
    /** Number of games played with easy */
    playedEZ?: ModStatsDTO | undefined;
    /** Number of games played with half time */
    playedHT?: ModStatsDTO | undefined;
    /** Number of games played with hidden */
    playedHD?: ModStatsDTO | undefined;
    /** Number of games played with hard rock */
    playedHR?: ModStatsDTO | undefined;
    /** Number of games played with double time */
    playedDT?: ModStatsDTO | undefined;
    /** Number of games played with flashlight */
    playedFL?: ModStatsDTO | undefined;
    /** Number of games played with both hidden and hard rock */
    playedHDHR?: ModStatsDTO | undefined;
    /** Number of games played with both hidden and double time */
    playedHDDT?: ModStatsDTO | undefined;
    /** Number of games played with both hidden and easy */
    playedHDEZ?: ModStatsDTO | undefined;
}

/** Represents data used to construct a rating delta chart for a player */
export class PlayerRatingChartDTO implements IPlayerRatingChartDTO {
    /** List of data points used to construct the chart */
    chartData!: PlayerRatingChartDataPointDTO[][];

    constructor(data?: IPlayerRatingChartDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.chartData = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["chartData"])) {
                this.chartData = [] as any;
                for (let item of _data["chartData"])
                    this.chartData!.push(item);
            }
        }
    }

    static fromJS(data: any): PlayerRatingChartDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerRatingChartDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.chartData)) {
            data["chartData"] = [];
            for (let item of this.chartData)
                data["chartData"].push(item);
        }
        return data;
    }
}

/** Represents data used to construct a rating delta chart for a player */
export interface IPlayerRatingChartDTO {
    /** List of data points used to construct the chart */
    chartData: PlayerRatingChartDataPointDTO[][];
}

/** Represents a data point used to construct a rating chart for a player */
export class PlayerRatingChartDataPointDTO implements IPlayerRatingChartDataPointDTO {
    /** Match name */
    name!: string;
    /** Match id */
    matchId?: number | undefined;
    /** osu! match id */
    matchOsuId?: number | undefined;
    /** Match cost of the player */
    matchCost?: number | undefined;
    /** Rating of the player before this match occurred */
    ratingBefore!: number;
    /** Rating of the player after this match occurred */
    ratingAfter!: number;
    /** Volatility of the player before this match occurred */
    volatilityBefore!: number;
    /** Volatility of the player after this match occurred */
    volatilityAfter!: number;
    /** Difference in rating for the player after this match occurred */
    readonly ratingChange!: number;
    /** Difference in volatility for the player after this match occurred */
    readonly volatilityChange!: number;
    /** Indicates whether this data point is from a rating change that occurred outside of a match (i.e. decay) */
    isAdjustment!: boolean;
    /** Match start time */
    timestamp?: Date | undefined;

    constructor(data?: IPlayerRatingChartDataPointDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.matchId = _data["matchId"];
            this.matchOsuId = _data["matchOsuId"];
            this.matchCost = _data["matchCost"];
            this.ratingBefore = _data["ratingBefore"];
            this.ratingAfter = _data["ratingAfter"];
            this.volatilityBefore = _data["volatilityBefore"];
            this.volatilityAfter = _data["volatilityAfter"];
            (<any>this).ratingChange = _data["ratingChange"];
            (<any>this).volatilityChange = _data["volatilityChange"];
            this.isAdjustment = _data["isAdjustment"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PlayerRatingChartDataPointDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerRatingChartDataPointDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["matchId"] = this.matchId;
        data["matchOsuId"] = this.matchOsuId;
        data["matchCost"] = this.matchCost;
        data["ratingBefore"] = this.ratingBefore;
        data["ratingAfter"] = this.ratingAfter;
        data["volatilityBefore"] = this.volatilityBefore;
        data["volatilityAfter"] = this.volatilityAfter;
        data["ratingChange"] = this.ratingChange;
        data["volatilityChange"] = this.volatilityChange;
        data["isAdjustment"] = this.isAdjustment;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        return data;
    }
}

/** Represents a data point used to construct a rating chart for a player */
export interface IPlayerRatingChartDataPointDTO {
    /** Match name */
    name: string;
    /** Match id */
    matchId?: number | undefined;
    /** osu! match id */
    matchOsuId?: number | undefined;
    /** Match cost of the player */
    matchCost?: number | undefined;
    /** Rating of the player before this match occurred */
    ratingBefore: number;
    /** Rating of the player after this match occurred */
    ratingAfter: number;
    /** Volatility of the player before this match occurred */
    volatilityBefore: number;
    /** Volatility of the player after this match occurred */
    volatilityAfter: number;
    /** Difference in rating for the player after this match occurred */
    ratingChange: number;
    /** Difference in volatility for the player after this match occurred */
    volatilityChange: number;
    /** Indicates whether this data point is from a rating change that occurred outside of a match (i.e. decay) */
    isAdjustment: boolean;
    /** Match start time */
    timestamp?: Date | undefined;
}

/** Describes tournament rating based information for a player in a ruleset that are current and not time specific */
export class PlayerRatingDTO implements IPlayerRatingDTO {
    /** Represents osu! play modes */
    ruleset!: Ruleset;
    /** Rating */
    rating!: number;
    /** Rating volatility */
    volatility!: number;
    /** Global rating percentile */
    percentile!: number;
    /** Global rank */
    globalRank!: number;
    /** Country rank */
    countryRank!: number;
    /** Player id */
    playerId!: number;
    /** A collection of adjustments that describe the changes resulting in the final rating */
    adjustments!: RatingAdjustmentDTO[];

    constructor(data?: IPlayerRatingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.adjustments = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ruleset = _data["ruleset"];
            this.rating = _data["rating"];
            this.volatility = _data["volatility"];
            this.percentile = _data["percentile"];
            this.globalRank = _data["globalRank"];
            this.countryRank = _data["countryRank"];
            this.playerId = _data["playerId"];
            if (Array.isArray(_data["adjustments"])) {
                this.adjustments = [] as any;
                for (let item of _data["adjustments"])
                    this.adjustments!.push(RatingAdjustmentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlayerRatingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerRatingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleset"] = this.ruleset;
        data["rating"] = this.rating;
        data["volatility"] = this.volatility;
        data["percentile"] = this.percentile;
        data["globalRank"] = this.globalRank;
        data["countryRank"] = this.countryRank;
        data["playerId"] = this.playerId;
        if (Array.isArray(this.adjustments)) {
            data["adjustments"] = [];
            for (let item of this.adjustments)
                data["adjustments"].push(item.toJSON());
        }
        return data;
    }
}

/** Describes tournament rating based information for a player in a ruleset that are current and not time specific */
export interface IPlayerRatingDTO {
    /** Represents osu! play modes */
    ruleset: Ruleset;
    /** Rating */
    rating: number;
    /** Rating volatility */
    volatility: number;
    /** Global rating percentile */
    percentile: number;
    /** Global rank */
    globalRank: number;
    /** Country rank */
    countryRank: number;
    /** Player id */
    playerId: number;
    /** A collection of adjustments that describe the changes resulting in the final rating */
    adjustments: RatingAdjustmentDTO[];
}

/** Describes tournament rating based information for a player in a ruleset with additional statistics */
export class PlayerRatingStatsDTO extends PlayerRatingDTO implements IPlayerRatingStatsDTO {
    /** Total number of tournaments played */
    tournamentsPlayed!: number;
    /** Total number of matches played */
    matchesPlayed!: number;
    /** Match win rate */
    winRate!: number;
    /** Rating tier progress information */
    rankProgress!: RankProgressDTO;
    /** Denotes the current rating as being provisional */
    isProvisional!: boolean;

    constructor(data?: IPlayerRatingStatsDTO) {
        super(data);
        if (!data) {
            this.rankProgress = new RankProgressDTO();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tournamentsPlayed = _data["tournamentsPlayed"];
            this.matchesPlayed = _data["matchesPlayed"];
            this.winRate = _data["winRate"];
            this.rankProgress = _data["rankProgress"] ? RankProgressDTO.fromJS(_data["rankProgress"]) : new RankProgressDTO();
            this.isProvisional = _data["isProvisional"];
        }
    }

    static override fromJS(data: any): PlayerRatingStatsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerRatingStatsDTO();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tournamentsPlayed"] = this.tournamentsPlayed;
        data["matchesPlayed"] = this.matchesPlayed;
        data["winRate"] = this.winRate;
        data["rankProgress"] = this.rankProgress ? this.rankProgress.toJSON() : <any>undefined;
        data["isProvisional"] = this.isProvisional;
        super.toJSON(data);
        return data;
    }
}

/** Describes tournament rating based information for a player in a ruleset with additional statistics */
export interface IPlayerRatingStatsDTO extends IPlayerRatingDTO {
    /** Total number of tournaments played */
    tournamentsPlayed: number;
    /** Total number of matches played */
    matchesPlayed: number;
    /** Match win rate */
    winRate: number;
    /** Rating tier progress information */
    rankProgress: RankProgressDTO;
    /** Denotes the current rating as being provisional */
    isProvisional: boolean;
}

/** Represents a search result for a player for a given ruleset */
export class PlayerSearchResultDTO implements IPlayerSearchResultDTO {
    /** Id of the player */
    id!: number;
    /** osu! id of the player */
    osuId!: number;
    /** Rating of the player for the given ruleset */
    rating?: number | undefined;
    /** Current global rank of the player for the given ruleset */
    globalRank?: number | undefined;
    /** Current rating tier of the player for the given ruleset */
    readonly ratingTier?: string | undefined;
    /** osu! username of the player */
    username?: string | undefined;
    /** Link to an osu! thumbnail for the player */
    thumbnail!: string;

    constructor(data?: IPlayerSearchResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.osuId = _data["osuId"];
            this.rating = _data["rating"];
            this.globalRank = _data["globalRank"];
            (<any>this).ratingTier = _data["ratingTier"];
            this.username = _data["username"];
            this.thumbnail = _data["thumbnail"];
        }
    }

    static fromJS(data: any): PlayerSearchResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerSearchResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["osuId"] = this.osuId;
        data["rating"] = this.rating;
        data["globalRank"] = this.globalRank;
        data["ratingTier"] = this.ratingTier;
        data["username"] = this.username;
        data["thumbnail"] = this.thumbnail;
        return data;
    }
}

/** Represents a search result for a player for a given ruleset */
export interface IPlayerSearchResultDTO {
    /** Id of the player */
    id: number;
    /** osu! id of the player */
    osuId: number;
    /** Rating of the player for the given ruleset */
    rating?: number | undefined;
    /** Current global rank of the player for the given ruleset */
    globalRank?: number | undefined;
    /** Current rating tier of the player for the given ruleset */
    ratingTier?: string | undefined;
    /** osu! username of the player */
    username?: string | undefined;
    /** Link to an osu! thumbnail for the player */
    thumbnail: string;
}

/** Represents a collection of statistics for a player in a ruleset */
export class PlayerStatsDTO implements IPlayerStatsDTO {
    /** Player info */
    playerInfo!: PlayerCompactDTO;
    /** Represents osu! play modes */
    ruleset!: Ruleset;
    /** Base stats for the player */
    rating?: PlayerRatingStatsDTO | undefined;
    /** Match stats for the player */
    matchStats?: AggregatePlayerMatchStatsDTO | undefined;
    /** Mod stats for the player */
    modStats?: PlayerModStatsDTO | undefined;
    /** Tournament participation and performance stats for the player */
    tournamentStats?: PlayerTournamentStatsDTO | undefined;
    /** List of frequencies of the player's teammates */
    frequentTeammates?: PlayerFrequencyDTO[] | undefined;
    /** List of frequencies of the player's opponents */
    frequentOpponents?: PlayerFrequencyDTO[] | undefined;
    /** Rating chart for the player */
    ratingChart?: PlayerRatingChartDTO | undefined;

    constructor(data?: IPlayerStatsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.playerInfo = new PlayerCompactDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playerInfo = _data["playerInfo"] ? PlayerCompactDTO.fromJS(_data["playerInfo"]) : new PlayerCompactDTO();
            this.ruleset = _data["ruleset"];
            this.rating = _data["rating"] ? PlayerRatingStatsDTO.fromJS(_data["rating"]) : <any>undefined;
            this.matchStats = _data["matchStats"] ? AggregatePlayerMatchStatsDTO.fromJS(_data["matchStats"]) : <any>undefined;
            this.modStats = _data["modStats"] ? PlayerModStatsDTO.fromJS(_data["modStats"]) : <any>undefined;
            this.tournamentStats = _data["tournamentStats"] ? PlayerTournamentStatsDTO.fromJS(_data["tournamentStats"]) : <any>undefined;
            if (Array.isArray(_data["frequentTeammates"])) {
                this.frequentTeammates = [] as any;
                for (let item of _data["frequentTeammates"])
                    this.frequentTeammates!.push(PlayerFrequencyDTO.fromJS(item));
            }
            if (Array.isArray(_data["frequentOpponents"])) {
                this.frequentOpponents = [] as any;
                for (let item of _data["frequentOpponents"])
                    this.frequentOpponents!.push(PlayerFrequencyDTO.fromJS(item));
            }
            this.ratingChart = _data["ratingChart"] ? PlayerRatingChartDTO.fromJS(_data["ratingChart"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PlayerStatsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerStatsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playerInfo"] = this.playerInfo ? this.playerInfo.toJSON() : <any>undefined;
        data["ruleset"] = this.ruleset;
        data["rating"] = this.rating ? this.rating.toJSON() : <any>undefined;
        data["matchStats"] = this.matchStats ? this.matchStats.toJSON() : <any>undefined;
        data["modStats"] = this.modStats ? this.modStats.toJSON() : <any>undefined;
        data["tournamentStats"] = this.tournamentStats ? this.tournamentStats.toJSON() : <any>undefined;
        if (Array.isArray(this.frequentTeammates)) {
            data["frequentTeammates"] = [];
            for (let item of this.frequentTeammates)
                data["frequentTeammates"].push(item.toJSON());
        }
        if (Array.isArray(this.frequentOpponents)) {
            data["frequentOpponents"] = [];
            for (let item of this.frequentOpponents)
                data["frequentOpponents"].push(item.toJSON());
        }
        data["ratingChart"] = this.ratingChart ? this.ratingChart.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a collection of statistics for a player in a ruleset */
export interface IPlayerStatsDTO {
    /** Player info */
    playerInfo: PlayerCompactDTO;
    /** Represents osu! play modes */
    ruleset: Ruleset;
    /** Base stats for the player */
    rating?: PlayerRatingStatsDTO | undefined;
    /** Match stats for the player */
    matchStats?: AggregatePlayerMatchStatsDTO | undefined;
    /** Mod stats for the player */
    modStats?: PlayerModStatsDTO | undefined;
    /** Tournament participation and performance stats for the player */
    tournamentStats?: PlayerTournamentStatsDTO | undefined;
    /** List of frequencies of the player's teammates */
    frequentTeammates?: PlayerFrequencyDTO[] | undefined;
    /** List of frequencies of the player's opponents */
    frequentOpponents?: PlayerFrequencyDTO[] | undefined;
    /** Rating chart for the player */
    ratingChart?: PlayerRatingChartDTO | undefined;
}

/** Represents counts of participation in tournaments of differing team sizes */
export class PlayerTournamentLobbySizeCountDTO implements IPlayerTournamentLobbySizeCountDTO {
    /** Number of 1v1 tournaments played */
    count1v1?: number | undefined;
    /** Number of 2v2 tournaments played */
    count2v2?: number | undefined;
    /** Number of 3v3 tournaments played */
    count3v3?: number | undefined;
    /** Number of 4v4 tournaments played */
    count4v4?: number | undefined;
    /** Number of tournaments played outside of standard team sizes */
    countOther?: number | undefined;

    constructor(data?: IPlayerTournamentLobbySizeCountDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count1v1 = _data["count1v1"];
            this.count2v2 = _data["count2v2"];
            this.count3v3 = _data["count3v3"];
            this.count4v4 = _data["count4v4"];
            this.countOther = _data["countOther"];
        }
    }

    static fromJS(data: any): PlayerTournamentLobbySizeCountDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerTournamentLobbySizeCountDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count1v1"] = this.count1v1;
        data["count2v2"] = this.count2v2;
        data["count3v3"] = this.count3v3;
        data["count4v4"] = this.count4v4;
        data["countOther"] = this.countOther;
        return data;
    }
}

/** Represents counts of participation in tournaments of differing team sizes */
export interface IPlayerTournamentLobbySizeCountDTO {
    /** Number of 1v1 tournaments played */
    count1v1?: number | undefined;
    /** Number of 2v2 tournaments played */
    count2v2?: number | undefined;
    /** Number of 3v3 tournaments played */
    count3v3?: number | undefined;
    /** Number of 4v4 tournaments played */
    count4v4?: number | undefined;
    /** Number of tournaments played outside of standard team sizes */
    countOther?: number | undefined;
}

/** Represents match cost data across an entire tournament for a player */
export class PlayerTournamentMatchCostDTO implements IPlayerTournamentMatchCostDTO {
    /** Id of the player */
    playerId!: number;
    /** Id of the tournament */
    tournamentId!: number;
    /** Name of the tournament */
    tournamentName!: string;
    /** Abbreviated name of the tournament */
    tournamentAcronym!: string;
    /** Represents osu! play modes */
    ruleset!: Ruleset;
    /** Average match cost across the tournament for the player */
    matchCost!: number;

    constructor(data?: IPlayerTournamentMatchCostDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playerId = _data["playerId"];
            this.tournamentId = _data["tournamentId"];
            this.tournamentName = _data["tournamentName"];
            this.tournamentAcronym = _data["tournamentAcronym"];
            this.ruleset = _data["ruleset"];
            this.matchCost = _data["matchCost"];
        }
    }

    static fromJS(data: any): PlayerTournamentMatchCostDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerTournamentMatchCostDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playerId"] = this.playerId;
        data["tournamentId"] = this.tournamentId;
        data["tournamentName"] = this.tournamentName;
        data["tournamentAcronym"] = this.tournamentAcronym;
        data["ruleset"] = this.ruleset;
        data["matchCost"] = this.matchCost;
        return data;
    }
}

/** Represents match cost data across an entire tournament for a player */
export interface IPlayerTournamentMatchCostDTO {
    /** Id of the player */
    playerId: number;
    /** Id of the tournament */
    tournamentId: number;
    /** Name of the tournament */
    tournamentName: string;
    /** Abbreviated name of the tournament */
    tournamentAcronym: string;
    /** Represents osu! play modes */
    ruleset: Ruleset;
    /** Average match cost across the tournament for the player */
    matchCost: number;
}

/** Represents statistics for a player regarding tournament participation and performance */
export class PlayerTournamentStatsDTO implements IPlayerTournamentStatsDTO {
    /** Counts of participation in tournaments of differing team sizes for the player */
    lobbySizeCounts!: PlayerTournamentLobbySizeCountDTO;
    /** List of best tournament performances for the player */
    bestPerformances!: PlayerTournamentMatchCostDTO[];
    /** List of recent tournament performances for the player */
    recentPerformances!: PlayerTournamentMatchCostDTO[];

    constructor(data?: IPlayerTournamentStatsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.lobbySizeCounts = new PlayerTournamentLobbySizeCountDTO();
            this.bestPerformances = [];
            this.recentPerformances = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lobbySizeCounts = _data["lobbySizeCounts"] ? PlayerTournamentLobbySizeCountDTO.fromJS(_data["lobbySizeCounts"]) : new PlayerTournamentLobbySizeCountDTO();
            if (Array.isArray(_data["bestPerformances"])) {
                this.bestPerformances = [] as any;
                for (let item of _data["bestPerformances"])
                    this.bestPerformances!.push(PlayerTournamentMatchCostDTO.fromJS(item));
            }
            if (Array.isArray(_data["recentPerformances"])) {
                this.recentPerformances = [] as any;
                for (let item of _data["recentPerformances"])
                    this.recentPerformances!.push(PlayerTournamentMatchCostDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlayerTournamentStatsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PlayerTournamentStatsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lobbySizeCounts"] = this.lobbySizeCounts ? this.lobbySizeCounts.toJSON() : <any>undefined;
        if (Array.isArray(this.bestPerformances)) {
            data["bestPerformances"] = [];
            for (let item of this.bestPerformances)
                data["bestPerformances"].push(item.toJSON());
        }
        if (Array.isArray(this.recentPerformances)) {
            data["recentPerformances"] = [];
            for (let item of this.recentPerformances)
                data["recentPerformances"].push(item.toJSON());
        }
        return data;
    }
}

/** Represents statistics for a player regarding tournament participation and performance */
export interface IPlayerTournamentStatsDTO {
    /** Counts of participation in tournaments of differing team sizes for the player */
    lobbySizeCounts: PlayerTournamentLobbySizeCountDTO;
    /** List of best tournament performances for the player */
    bestPerformances: PlayerTournamentMatchCostDTO[];
    /** List of recent tournament performances for the player */
    recentPerformances: PlayerTournamentMatchCostDTO[];
}

/** Represents rating tier progress data */
export class RankProgressDTO implements IRankProgressDTO {
    /** Current tier */
    currentTier!: string;
    /** Current sub tier */
    currentSubTier?: number | undefined;
    /** Rating required to reach next sub tier */
    ratingForNextTier!: number;
    /** Rating required to reach next major tier */
    ratingForNextMajorTier!: number;
    /** Next major tier following current tier */
    nextMajorTier?: string | undefined;
    /** Progress to the next sub tier as a percentage */
    subTierFillPercentage?: number | undefined;
    /** Progress to the next major tier as a percentage */
    majorTierFillPercentage?: number | undefined;

    constructor(data?: IRankProgressDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentTier = _data["currentTier"];
            this.currentSubTier = _data["currentSubTier"];
            this.ratingForNextTier = _data["ratingForNextTier"];
            this.ratingForNextMajorTier = _data["ratingForNextMajorTier"];
            this.nextMajorTier = _data["nextMajorTier"];
            this.subTierFillPercentage = _data["subTierFillPercentage"];
            this.majorTierFillPercentage = _data["majorTierFillPercentage"];
        }
    }

    static fromJS(data: any): RankProgressDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RankProgressDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentTier"] = this.currentTier;
        data["currentSubTier"] = this.currentSubTier;
        data["ratingForNextTier"] = this.ratingForNextTier;
        data["ratingForNextMajorTier"] = this.ratingForNextMajorTier;
        data["nextMajorTier"] = this.nextMajorTier;
        data["subTierFillPercentage"] = this.subTierFillPercentage;
        data["majorTierFillPercentage"] = this.majorTierFillPercentage;
        return data;
    }
}

/** Represents rating tier progress data */
export interface IRankProgressDTO {
    /** Current tier */
    currentTier: string;
    /** Current sub tier */
    currentSubTier?: number | undefined;
    /** Rating required to reach next sub tier */
    ratingForNextTier: number;
    /** Rating required to reach next major tier */
    ratingForNextMajorTier: number;
    /** Next major tier following current tier */
    nextMajorTier?: string | undefined;
    /** Progress to the next sub tier as a percentage */
    subTierFillPercentage?: number | undefined;
    /** Progress to the next major tier as a percentage */
    majorTierFillPercentage?: number | undefined;
}

/** Describes a single change to a PlayerRating */
export class RatingAdjustmentDTO implements IRatingAdjustmentDTO {
    /** Represents the different types of events that result in the generation of a Database.Entities.Processor.RatingAdjustment */
    adjustmentType!: RatingAdjustmentType;
    /** Timestamp of when the adjustment was applied */
    timestamp!: Date;
    /** Rating before the adjustment */
    ratingBefore!: number;
    /** Rating after the adjustment */
    ratingAfter!: number;
    /** Total change in rating */
    ratingDelta!: number;
    /** Rating volatility before the adjustment */
    volatilityBefore!: number;
    /** Rating volatility after the adjustment */
    volatilityAfter!: number;
    /** Total change in rating volatility */
    volatilityDelta!: number;
    /** Id of the match the adjustment was created for if available */
    matchId?: number | undefined;

    constructor(data?: IRatingAdjustmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adjustmentType = _data["adjustmentType"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.ratingBefore = _data["ratingBefore"];
            this.ratingAfter = _data["ratingAfter"];
            this.ratingDelta = _data["ratingDelta"];
            this.volatilityBefore = _data["volatilityBefore"];
            this.volatilityAfter = _data["volatilityAfter"];
            this.volatilityDelta = _data["volatilityDelta"];
            this.matchId = _data["matchId"];
        }
    }

    static fromJS(data: any): RatingAdjustmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RatingAdjustmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adjustmentType"] = this.adjustmentType;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["ratingBefore"] = this.ratingBefore;
        data["ratingAfter"] = this.ratingAfter;
        data["ratingDelta"] = this.ratingDelta;
        data["volatilityBefore"] = this.volatilityBefore;
        data["volatilityAfter"] = this.volatilityAfter;
        data["volatilityDelta"] = this.volatilityDelta;
        data["matchId"] = this.matchId;
        return data;
    }
}

/** Describes a single change to a PlayerRating */
export interface IRatingAdjustmentDTO {
    /** Represents the different types of events that result in the generation of a Database.Entities.Processor.RatingAdjustment */
    adjustmentType: RatingAdjustmentType;
    /** Timestamp of when the adjustment was applied */
    timestamp: Date;
    /** Rating before the adjustment */
    ratingBefore: number;
    /** Rating after the adjustment */
    ratingAfter: number;
    /** Total change in rating */
    ratingDelta: number;
    /** Rating volatility before the adjustment */
    volatilityBefore: number;
    /** Rating volatility after the adjustment */
    volatilityAfter: number;
    /** Total change in rating volatility */
    volatilityDelta: number;
    /** Id of the match the adjustment was created for if available */
    matchId?: number | undefined;
}

/** Represents the different types of events that result in the generation of a Database.Entities.Processor.RatingAdjustment */
export enum RatingAdjustmentType {
    /** The Database.Entities.Processor.RatingAdjustment is the initial rating */
    Initial = 0,
    /** The Database.Entities.Processor.RatingAdjustment is the result of a period of inactivity (decay) */
    Decay = 1,
    /** The Database.Entities.Processor.RatingAdjustment is the result of participation in a Database.Entities.Match */
    Match = 2,
}

/** Represents osu! play modes */
export enum Ruleset {
    /** osu! (standard) */
    Osu = 0,
    /** osu! Taiko */
    Taiko = 1,
    /** osu! Catch (aka Fruits) */
    Catch = 2,
    /**
    * osu! Mania
	* 
	* Encompasses all of the osu!mania ruleset and represents a ruleset that has
	* not yet been identified as either Database.Enums.Ruleset.Mania4k or Database.Enums.Ruleset.Mania7k
    */
    ManiaOther = 3,
    /** osu! Mania 4k variant */
    Mania4k = 4,
    /** osu! Mania 7k variant */
    Mania7k = 5,
}

/** The status of a Database.Entities.GameScore in the processing flow */
export enum ScoreProcessingStatus {
    /** The Database.Entities.GameScore needs automation checks */
    NeedsAutomationChecks = 0,
    /**
    * The Database.Entities.GameScore is awaiting verification from a
	* Database.Entities.User with verifier permission
    */
    NeedsVerification = 1,
    /** The Database.Entities.GameScore has completed all processing steps */
    Done = 2,
}

/**
* The reason why a Database.Entities.GameScore is rejected
*
* Bitwise flag
*/
export enum ScoreRejectionReason {
    /** The Database.Entities.GameScore is not rejected */
    None = 0,
    /** The Database.Entities.GameScore's Database.Entities.GameScore.Score is below the minimum threshold */
    ScoreBelowMinimum = 1,
    /** The Database.Entities.GameScore was set with any Database.Enums.Mods.InvalidMods */
    InvalidMods = 2,
    /** The Database.Entities.GameScore's Database.Enums.Ruleset does not match that of the parent Database.Entities.Tournament */
    RulesetMismatch = 4,
    /** The Database.Entities.Game the Database.Entities.GameScore was set in was rejected */
    RejectedGame = 8,
}

/** Represents the scoring method (win condition) for a Database.Entities.Game */
export enum ScoringType {
    /** Scoring based on Score v1 */
    Score = 0,
    /** Scoring based on accuracy */
    Accuracy = 1,
    /** Scoring based on combo */
    Combo = 2,
    /** Scoring based on Score v2 */
    ScoreV2 = 3,
}

/** Represents a collection of search results */
export class SearchResponseCollectionDTO implements ISearchResponseCollectionDTO {
    /** A collection of search results for tournaments matching the search query */
    tournaments!: TournamentSearchResultDTO[];
    /** A collection of search results for matches matching the search query */
    matches!: MatchSearchResultDTO[];
    /** A collection of search results for players matching the search query */
    players!: PlayerSearchResultDTO[];

    constructor(data?: ISearchResponseCollectionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tournaments = [];
            this.matches = [];
            this.players = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tournaments"])) {
                this.tournaments = [] as any;
                for (let item of _data["tournaments"])
                    this.tournaments!.push(TournamentSearchResultDTO.fromJS(item));
            }
            if (Array.isArray(_data["matches"])) {
                this.matches = [] as any;
                for (let item of _data["matches"])
                    this.matches!.push(MatchSearchResultDTO.fromJS(item));
            }
            if (Array.isArray(_data["players"])) {
                this.players = [] as any;
                for (let item of _data["players"])
                    this.players!.push(PlayerSearchResultDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchResponseCollectionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SearchResponseCollectionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tournaments)) {
            data["tournaments"] = [];
            for (let item of this.tournaments)
                data["tournaments"].push(item.toJSON());
        }
        if (Array.isArray(this.matches)) {
            data["matches"] = [];
            for (let item of this.matches)
                data["matches"].push(item.toJSON());
        }
        if (Array.isArray(this.players)) {
            data["players"] = [];
            for (let item of this.players)
                data["players"].push(item.toJSON());
        }
        return data;
    }
}

/** Represents a collection of search results */
export interface ISearchResponseCollectionDTO {
    /** A collection of search results for tournaments matching the search query */
    tournaments: TournamentSearchResultDTO[];
    /** A collection of search results for matches matching the search query */
    matches: MatchSearchResultDTO[];
    /** A collection of search results for players matching the search query */
    players: PlayerSearchResultDTO[];
}

/** Represents the team a Database.Entities.Player was on when a Database.Entities.GameScore was set */
export enum Team {
    /** No team */
    NoTeam = 0,
    /** Team blue */
    Blue = 1,
    /** Team red */
    Red = 2,
}

/** Represents the team type used for a Database.Entities.Game (See <a href="https://osu.ppy.sh/wiki/en/Client/Interface/Multiplayer"> osu! wiki - Multiplayer</a>) */
export enum TeamType {
    /** Free for all */
    HeadToHead = 0,
    /**
    * Free for all (Tag format)
	* 
	* All players play tag on the same beatmap
    */
    TagCoop = 1,
    /** Team red vs team blue */
    TeamVs = 2,
    /** Team red vs team blue (Tag format) */
    TagTeamVs = 3,
}

/** Represents a tournament with minimal data */
export class TournamentCompactDTO implements ITournamentCompactDTO {
    /** Id */
    id!: number;
    /** The timestamp of submission */
    created!: Date;
    /** Full name */
    name!: string;
    abbreviation!: string;
    /** The osu! forum post or wiki page this tournament is featured by (If both are present, the osu! forum post should be used) */
    forumUrl!: string;
    /** Lowest rank a player can be to participate */
    rankRangeLowerBound!: number;
    /** Represents osu! play modes */
    ruleset!: Ruleset;
    /** Expected in-match team size */
    lobbySize!: number;
    /** The start date of the first match */
    startTime!: Date;
    /** The end date of the last match */
    endTime!: Date;
    /** The verification status of a Database.Entities.Tournament,
Database.Entities.Match, Database.Entities.Game, or Database.Entities.GameScore */
    verificationStatus!: VerificationStatus;
    /** The status of a Database.Entities.Tournament in the processing flow */
    processingStatus!: TournamentProcessingStatus;
    /** The reason why a Database.Entities.Tournament is rejected */
    rejectionReason!: TournamentRejectionReason;
    /** The user that submitted the tournament */
    submittedByUser?: UserCompactDTO | undefined;
    /** The user that verified the tournament */
    verifiedByUser?: UserCompactDTO | undefined;

    constructor(data?: ITournamentCompactDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.abbreviation = _data["abbreviation"];
            this.forumUrl = _data["forumUrl"];
            this.rankRangeLowerBound = _data["rankRangeLowerBound"];
            this.ruleset = _data["ruleset"];
            this.lobbySize = _data["lobbySize"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.verificationStatus = _data["verificationStatus"];
            this.processingStatus = _data["processingStatus"];
            this.rejectionReason = _data["rejectionReason"];
            this.submittedByUser = _data["submittedByUser"] ? UserCompactDTO.fromJS(_data["submittedByUser"]) : <any>undefined;
            this.verifiedByUser = _data["verifiedByUser"] ? UserCompactDTO.fromJS(_data["verifiedByUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TournamentCompactDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TournamentCompactDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["abbreviation"] = this.abbreviation;
        data["forumUrl"] = this.forumUrl;
        data["rankRangeLowerBound"] = this.rankRangeLowerBound;
        data["ruleset"] = this.ruleset;
        data["lobbySize"] = this.lobbySize;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["verificationStatus"] = this.verificationStatus;
        data["processingStatus"] = this.processingStatus;
        data["rejectionReason"] = this.rejectionReason;
        data["submittedByUser"] = this.submittedByUser ? this.submittedByUser.toJSON() : <any>undefined;
        data["verifiedByUser"] = this.verifiedByUser ? this.verifiedByUser.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a tournament with minimal data */
export interface ITournamentCompactDTO {
    /** Id */
    id: number;
    /** The timestamp of submission */
    created: Date;
    /** Full name */
    name: string;
    abbreviation: string;
    /** The osu! forum post or wiki page this tournament is featured by (If both are present, the osu! forum post should be used) */
    forumUrl: string;
    /** Lowest rank a player can be to participate */
    rankRangeLowerBound: number;
    /** Represents osu! play modes */
    ruleset: Ruleset;
    /** Expected in-match team size */
    lobbySize: number;
    /** The start date of the first match */
    startTime: Date;
    /** The end date of the last match */
    endTime: Date;
    /** The verification status of a Database.Entities.Tournament,
Database.Entities.Match, Database.Entities.Game, or Database.Entities.GameScore */
    verificationStatus: VerificationStatus;
    /** The status of a Database.Entities.Tournament in the processing flow */
    processingStatus: TournamentProcessingStatus;
    /** The reason why a Database.Entities.Tournament is rejected */
    rejectionReason: TournamentRejectionReason;
    /** The user that submitted the tournament */
    submittedByUser?: UserCompactDTO | undefined;
    /** The user that verified the tournament */
    verifiedByUser?: UserCompactDTO | undefined;
}

/** Represents a created tournament */
export class TournamentCreatedResultDTO extends CreatedResultBaseDTO implements ITournamentCreatedResultDTO {
    /** Represents data for constructing Microsoft.AspNetCore.Mvc.CreatedResult */
    readonly createdAtRouteValues!: CreatedAtRouteValues;
    /** The name of the tournament */
    name!: string;
    /** Acronym / shortened name of the tournament
<example>For osu! World Cup 2023, this value would be "OWC23"</example> */
    abbreviation!: string;
    /** List of created matches */
    matches!: MatchCreatedResultDTO[];

    constructor(data?: ITournamentCreatedResultDTO) {
        super(data);
        if (!data) {
            this.createdAtRouteValues = new CreatedAtRouteValues();
            this.matches = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            (<any>this).createdAtRouteValues = _data["createdAtRouteValues"] ? CreatedAtRouteValues.fromJS(_data["createdAtRouteValues"]) : new CreatedAtRouteValues();
            this.name = _data["name"];
            this.abbreviation = _data["abbreviation"];
            if (Array.isArray(_data["matches"])) {
                this.matches = [] as any;
                for (let item of _data["matches"])
                    this.matches!.push(MatchCreatedResultDTO.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): TournamentCreatedResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TournamentCreatedResultDTO();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAtRouteValues"] = this.createdAtRouteValues ? this.createdAtRouteValues.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["abbreviation"] = this.abbreviation;
        if (Array.isArray(this.matches)) {
            data["matches"] = [];
            for (let item of this.matches)
                data["matches"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Represents a created tournament */
export interface ITournamentCreatedResultDTO extends ICreatedResultBaseDTO {
    /** Represents data for constructing Microsoft.AspNetCore.Mvc.CreatedResult */
    createdAtRouteValues: CreatedAtRouteValues;
    /** The name of the tournament */
    name: string;
    /** Acronym / shortened name of the tournament
<example>For osu! World Cup 2023, this value would be "OWC23"</example> */
    abbreviation: string;
    /** List of created matches */
    matches: MatchCreatedResultDTO[];
}

/** Represents a tournament including optional data */
export class TournamentDTO extends TournamentCompactDTO implements ITournamentDTO {
    /** All associated match data (Will be empty for bulk requests such as List) */
    matches!: MatchDTO[];
    /** All admin notes associated with the tournament */
    adminNotes!: AdminNoteDTO[];

    constructor(data?: ITournamentDTO) {
        super(data);
        if (!data) {
            this.matches = [];
            this.adminNotes = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["matches"])) {
                this.matches = [] as any;
                for (let item of _data["matches"])
                    this.matches!.push(MatchDTO.fromJS(item));
            }
            if (Array.isArray(_data["adminNotes"])) {
                this.adminNotes = [] as any;
                for (let item of _data["adminNotes"])
                    this.adminNotes!.push(AdminNoteDTO.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): TournamentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TournamentDTO();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.matches)) {
            data["matches"] = [];
            for (let item of this.matches)
                data["matches"].push(item.toJSON());
        }
        if (Array.isArray(this.adminNotes)) {
            data["adminNotes"] = [];
            for (let item of this.adminNotes)
                data["adminNotes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Represents a tournament including optional data */
export interface ITournamentDTO extends ITournamentCompactDTO {
    /** All associated match data (Will be empty for bulk requests such as List) */
    matches: MatchDTO[];
    /** All admin notes associated with the tournament */
    adminNotes: AdminNoteDTO[];
}

/** The status of a Database.Entities.Tournament in the processing flow */
export enum TournamentProcessingStatus {
    /**
    * The Database.Entities.Tournament is awaiting approval from a
	* Database.Entities.User with verifier permission
	* 
	* Functions as the entry point to the processing flow. No entities owned by a Database.Entities.Tournament
	* will advance through the processing flow until approved.
    */
    NeedsApproval = 0,
    /**
    * The Database.Entities.Tournament has Database.Entities.Matches with a
	* Database.Enums.Verification.MatchProcessingStatus of Database.Enums.Verification.MatchProcessingStatus.NeedsData
    */
    NeedsMatchData = 1,
    /** The Database.Entities.Tournament needs automation checks */
    NeedsAutomationChecks = 2,
    /**
    * The Database.Entities.Tournament is awaiting verification from a
	* Database.Entities.User with verifier permission
    */
    NeedsVerification = 3,
    /** The Database.Entities.Tournament needs stat calculation */
    NeedsStatCalculation = 4,
    /** The tournament has completed all processing steps */
    Done = 5,
}

/** Defines how to sort the results of fetching all tournaments */
export enum TournamentQuerySortType {
    /** Sort by primary key */
    Id = 0,
    /** Sort by start date */
    StartTime = 1,
    /** Sort by name */
    Name = 2,
    /** Sort by created date */
    Created = 3,
}

/**
* The reason why a Database.Entities.Tournament is rejected
*
* Bitwise flag
*/
export enum TournamentRejectionReason {
    /** The Database.Entities.Tournament is not rejected */
    None = 0,
    /**
    * The Database.Entities.Tournament has no Database.Entities.Tournament.Matches with a
	* Database.Enums.Verification.VerificationStatus of Database.Enums.Verification.VerificationStatus.Verified or Database.Enums.Verification.VerificationStatus.PreVerified
    */
    NoVerifiedMatches = 1,
    /**
    * The Database.Entities.Tournament's number of Database.Entities.Tournament.Matches with a
	* Database.Enums.Verification.VerificationStatus of Database.Enums.Verification.VerificationStatus.Verified or
	* Database.Enums.Verification.VerificationStatus.PreVerified is below 80% of the total
    */
    NotEnoughVerifiedMatches = 2,
    /**
    * The Database.Entities.Tournament's win condition is not Database.Enums.ScoringType.ScoreV2
	* 
	* Only assigned via a "rejected submission". <br />
	* Covers cases such as gimmicky win conditions, mixed win conditions, etc
    */
    AbnormalWinCondition = 4,
    /**
    * The Database.Entities.Tournament's format is not suitable for ratings
	* 
	* Only assigned via a "rejected submission". <br />
	* Covers cases such as excessive gimmicks, relax, multiple modes, etc
    */
    AbnormalFormat = 8,
    /**
    * The Database.Entities.Tournament's lobby sizes are not consistent.
	* 
	* Only assigned via a "rejected submission". <br />
	* Covers cases such as > 2 teams in lobby at once, async lobbies, team size gimmicks, varying team sizes, etc
    */
    VaryingLobbySize = 16,
    /**
    * The Database.Entities.Tournament's data is incomplete or not recoverable
	* Covers cases where match links are lost to time, private,
	* main sheet is deleted, missing rounds, etc.
	* 
	* Only assigned via a "rejected submission". <br />
	* Covers cases where match links are lost to time / dead / private, main sheet is deleted, missing rounds, etc
    */
    IncompleteData = 32,
}

/** Represents a search result for a tournament */
export class TournamentSearchResultDTO implements ITournamentSearchResultDTO {
    /** Id of the tournament */
    id!: number;
    /** Represents osu! play modes */
    ruleset!: Ruleset;
    /** Expected in-match team size */
    lobbySize!: number;
    /** Name of the tournament */
    name!: string;

    constructor(data?: ITournamentSearchResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ruleset = _data["ruleset"];
            this.lobbySize = _data["lobbySize"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TournamentSearchResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TournamentSearchResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ruleset"] = this.ruleset;
        data["lobbySize"] = this.lobbySize;
        data["name"] = this.name;
        return data;
    }
}

/** Represents a search result for a tournament */
export interface ITournamentSearchResultDTO {
    /** Id of the tournament */
    id: number;
    /** Represents osu! play modes */
    ruleset: Ruleset;
    /** Expected in-match team size */
    lobbySize: number;
    /** Name of the tournament */
    name: string;
}

/** An incoming tournament submission */
export class TournamentSubmissionDTO implements ITournamentSubmissionDTO {
    /** The name of the tournament */
    name!: string;
    /** Acronym / shortened name of the tournament
<example>For osu! World Cup 2023, this value would be "OWC23"</example> */
    abbreviation!: string;
    /** The osu! forum post advertising this tournament */
    forumUrl!: string;
    /** Lowest rank a player can be to participate in the tournament */
    rankRangeLowerBound!: number;
    /** Expected in-match team size */
    lobbySize!: number;
    /** Represents osu! play modes */
    ruleset!: Ruleset;
    /** Optional rejection reason. If set, the created tournament and all matches will be rejected
for this reason and go through no additional processing (Submissions with a rejection reason will only be accepted from admin users) */
    rejectionReason?: TournamentRejectionReason | undefined;
    /** List of osu! match ids */
    ids!: number[];
    /** A collection of pooled osu! beatmap ids */
    beatmapIds!: number[];

    constructor(data?: ITournamentSubmissionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
            this.beatmapIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.abbreviation = _data["abbreviation"];
            this.forumUrl = _data["forumUrl"];
            this.rankRangeLowerBound = _data["rankRangeLowerBound"];
            this.lobbySize = _data["lobbySize"];
            this.ruleset = _data["ruleset"];
            this.rejectionReason = _data["rejectionReason"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            if (Array.isArray(_data["beatmapIds"])) {
                this.beatmapIds = [] as any;
                for (let item of _data["beatmapIds"])
                    this.beatmapIds!.push(item);
            }
        }
    }

    static fromJS(data: any): TournamentSubmissionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TournamentSubmissionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["abbreviation"] = this.abbreviation;
        data["forumUrl"] = this.forumUrl;
        data["rankRangeLowerBound"] = this.rankRangeLowerBound;
        data["lobbySize"] = this.lobbySize;
        data["ruleset"] = this.ruleset;
        data["rejectionReason"] = this.rejectionReason;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        if (Array.isArray(this.beatmapIds)) {
            data["beatmapIds"] = [];
            for (let item of this.beatmapIds)
                data["beatmapIds"].push(item);
        }
        return data;
    }
}

/** An incoming tournament submission */
export interface ITournamentSubmissionDTO {
    /** The name of the tournament */
    name: string;
    /** Acronym / shortened name of the tournament
<example>For osu! World Cup 2023, this value would be "OWC23"</example> */
    abbreviation: string;
    /** The osu! forum post advertising this tournament */
    forumUrl: string;
    /** Lowest rank a player can be to participate in the tournament */
    rankRangeLowerBound: number;
    /** Expected in-match team size */
    lobbySize: number;
    /** Represents osu! play modes */
    ruleset: Ruleset;
    /** Optional rejection reason. If set, the created tournament and all matches will be rejected
for this reason and go through no additional processing (Submissions with a rejection reason will only be accepted from admin users) */
    rejectionReason?: TournamentRejectionReason | undefined;
    /** List of osu! match ids */
    ids: number[];
    /** A collection of pooled osu! beatmap ids */
    beatmapIds: number[];
}

/** Represents user information */
export class UserCompactDTO implements IUserCompactDTO {
    /** Id */
    id!: number;
    /** Timestamp of the user's last login to the o!TR website */
    lastLogin?: Date | undefined;
    /** The associated player */
    player!: PlayerCompactDTO;

    constructor(data?: IUserCompactDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.player = new PlayerCompactDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lastLogin = _data["lastLogin"] ? new Date(_data["lastLogin"].toString()) : <any>undefined;
            this.player = _data["player"] ? PlayerCompactDTO.fromJS(_data["player"]) : new PlayerCompactDTO();
        }
    }

    static fromJS(data: any): UserCompactDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserCompactDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lastLogin"] = this.lastLogin ? this.lastLogin.toISOString() : <any>undefined;
        data["player"] = this.player ? this.player.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents user information */
export interface IUserCompactDTO {
    /** Id */
    id: number;
    /** Timestamp of the user's last login to the o!TR website */
    lastLogin?: Date | undefined;
    /** The associated player */
    player: PlayerCompactDTO;
}

/** Represents user information including optional data */
export class UserDTO extends UserCompactDTO implements IUserDTO {
    /** List of permissions granted to the user */
    scopes!: string[];
    /** Settings of the user */
    settings!: UserSettingsDTO;

    constructor(data?: IUserDTO) {
        super(data);
        if (!data) {
            this.scopes = [];
            this.settings = new UserSettingsDTO();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            this.settings = _data["settings"] ? UserSettingsDTO.fromJS(_data["settings"]) : new UserSettingsDTO();
        }
    }

    static override fromJS(data: any): UserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserDTO();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

/** Represents user information including optional data */
export interface IUserDTO extends IUserCompactDTO {
    /** List of permissions granted to the user */
    scopes: string[];
    /** Settings of the user */
    settings: UserSettingsDTO;
}

/** Represents user controlled settings for otr-web */
export class UserSettingsDTO implements IUserSettingsDTO {
    /** Represents osu! play modes */
    ruleset!: Ruleset;
    /** Denotes whether the associated user has overwritten their default ruleset (If false, the default ruleset is always the same as the user's default ruleset on the osu! website) */
    rulesetIsControlled!: boolean;

    constructor(data?: IUserSettingsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ruleset = _data["ruleset"];
            this.rulesetIsControlled = _data["rulesetIsControlled"];
        }
    }

    static fromJS(data: any): UserSettingsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserSettingsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleset"] = this.ruleset;
        data["rulesetIsControlled"] = this.rulesetIsControlled;
        return data;
    }
}

/** Represents user controlled settings for otr-web */
export interface IUserSettingsDTO {
    /** Represents osu! play modes */
    ruleset: Ruleset;
    /** Denotes whether the associated user has overwritten their default ruleset (If false, the default ruleset is always the same as the user's default ruleset on the osu! website) */
    rulesetIsControlled: boolean;
}

/** The verification status of a Database.Entities.Tournament, Database.Entities.Match, Database.Entities.Game, or Database.Entities.GameScore */
export enum VerificationStatus {
    /** Verification status has not yet been assigned */
    None = 0,
    /** The Data Worker has identified an issue during processing */
    PreRejected = 1,
    /** The Data Worker has not identified any issues during processing */
    PreVerified = 2,
    /** Determined to be unfit for ratings by manual review */
    Rejected = 3,
    /** Determined to be fit for ratings by manual review */
    Verified = 4,
}

export class OtrApiResponse<TResult> {
    status: number;
    headers: { [key: string]: any; };
    result: TResult;

    constructor(status: number, headers: { [key: string]: any; }, result: TResult)
    {
        this.status = status;
        this.headers = headers;
        this.result = result;
    }
}

export class OtrApiError extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isOtrApiError = true;

    static isOtrApiError(obj: any): obj is OtrApiError {
        return obj.isOtrApiError === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new OtrApiError(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

/** Configuration required for o!TR API Wrappers */
export interface IOtrApiWrapperConfiguration {
  /** The base URL of the API */
  baseUrl: string;

  /** Defaults used to created the inner axios client */
  clientConfiguration?: CreateAxiosDefaults;

  /** Function to configure the inner axios client after creation . Called during creation of the wrapper */
  postConfigureClientMethod?: (instance: AxiosInstance) => void;
}